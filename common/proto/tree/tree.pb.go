// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tree.proto

/*
Package tree is a generated protocol buffer package.

It is generated from these files:
	tree.proto

It has these top-level messages:
	ReadNodeRequest
	ReadNodeResponse
	ListNodesRequest
	ListNodesResponse
	CreateNodeRequest
	CreateNodeResponse
	UpdateNodeRequest
	UpdateNodeResponse
	DeleteNodeRequest
	DeleteNodeResponse
	IndexationSession
	IndexationOperation
	OpenSessionRequest
	OpenSessionResponse
	FlushSessionRequest
	FlushSessionResponse
	CloseSessionRequest
	CloseSessionResponse
	WatchNodeRequest
	WatchNodeResponse
	SearchRequest
	SearchResponse
	CreateVersionRequest
	CreateVersionResponse
	ListVersionsRequest
	ListVersionsResponse
	HeadVersionRequest
	HeadVersionResponse
	StoreVersionRequest
	StoreVersionResponse
	PruneVersionsRequest
	PruneVersionsResponse
	VersioningPolicy
	VersioningKeepPeriod
	Node
	WorkspaceRelativePath
	ChangeLog
	Query
	GeoQuery
	GeoPoint
	NodeChangeEvent
	GetEncryptionKeyRequest
	GetEncryptionKeyResponse
	SyncChange
	SyncChangeNode
	PutSyncChangeResponse
	SearchSyncChangeRequest
*/
package tree

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	client "github.com/micro/go-micro/client"
	server "github.com/micro/go-micro/server"
	context "golang.org/x/net/context"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ==========================================================
// * Standard Messages
// ==========================================================
type NodeType int32

const (
	NodeType_UNKNOWN    NodeType = 0
	NodeType_LEAF       NodeType = 1
	NodeType_COLLECTION NodeType = 2
)

var NodeType_name = map[int32]string{
	0: "UNKNOWN",
	1: "LEAF",
	2: "COLLECTION",
}
var NodeType_value = map[string]int32{
	"UNKNOWN":    0,
	"LEAF":       1,
	"COLLECTION": 2,
}

func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}
func (NodeType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type NodeChangeEvent_EventType int32

const (
	NodeChangeEvent_CREATE         NodeChangeEvent_EventType = 0
	NodeChangeEvent_READ           NodeChangeEvent_EventType = 1
	NodeChangeEvent_UPDATE_PATH    NodeChangeEvent_EventType = 2
	NodeChangeEvent_UPDATE_CONTENT NodeChangeEvent_EventType = 3
	NodeChangeEvent_UPDATE_META    NodeChangeEvent_EventType = 4
	NodeChangeEvent_DELETE         NodeChangeEvent_EventType = 5
)

var NodeChangeEvent_EventType_name = map[int32]string{
	0: "CREATE",
	1: "READ",
	2: "UPDATE_PATH",
	3: "UPDATE_CONTENT",
	4: "UPDATE_META",
	5: "DELETE",
}
var NodeChangeEvent_EventType_value = map[string]int32{
	"CREATE":         0,
	"READ":           1,
	"UPDATE_PATH":    2,
	"UPDATE_CONTENT": 3,
	"UPDATE_META":    4,
	"DELETE":         5,
}

func (x NodeChangeEvent_EventType) String() string {
	return proto.EnumName(NodeChangeEvent_EventType_name, int32(x))
}
func (NodeChangeEvent_EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{40, 0}
}

type SyncChange_Type int32

const (
	SyncChange_unknown SyncChange_Type = 0
	SyncChange_create  SyncChange_Type = 1
	SyncChange_delete  SyncChange_Type = 2
	SyncChange_path    SyncChange_Type = 3
	SyncChange_content SyncChange_Type = 4
)

var SyncChange_Type_name = map[int32]string{
	0: "unknown",
	1: "create",
	2: "delete",
	3: "path",
	4: "content",
}
var SyncChange_Type_value = map[string]int32{
	"unknown": 0,
	"create":  1,
	"delete":  2,
	"path":    3,
	"content": 4,
}

func (x SyncChange_Type) String() string {
	return proto.EnumName(SyncChange_Type_name, int32(x))
}
func (SyncChange_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{43, 0} }

// Request / Responses Messages
type ReadNodeRequest struct {
	Node        *Node `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
	WithCommits bool  `protobuf:"varint,2,opt,name=WithCommits" json:"WithCommits,omitempty"`
}

func (m *ReadNodeRequest) Reset()                    { *m = ReadNodeRequest{} }
func (m *ReadNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadNodeRequest) ProtoMessage()               {}
func (*ReadNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ReadNodeRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *ReadNodeRequest) GetWithCommits() bool {
	if m != nil {
		return m.WithCommits
	}
	return false
}

type ReadNodeResponse struct {
	Success bool  `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	Node    *Node `protobuf:"bytes,2,opt,name=Node" json:"Node,omitempty"`
}

func (m *ReadNodeResponse) Reset()                    { *m = ReadNodeResponse{} }
func (m *ReadNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadNodeResponse) ProtoMessage()               {}
func (*ReadNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ReadNodeResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ReadNodeResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type ListNodesRequest struct {
	Node         *Node    `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
	Recursive    bool     `protobuf:"varint,2,opt,name=Recursive" json:"Recursive,omitempty"`
	Ancestors    bool     `protobuf:"varint,3,opt,name=Ancestors" json:"Ancestors,omitempty"`
	WithVersions bool     `protobuf:"varint,7,opt,name=WithVersions" json:"WithVersions,omitempty"`
	WithCommits  bool     `protobuf:"varint,8,opt,name=WithCommits" json:"WithCommits,omitempty"`
	Limit        int64    `protobuf:"varint,4,opt,name=Limit" json:"Limit,omitempty"`
	Offset       int64    `protobuf:"varint,5,opt,name=Offset" json:"Offset,omitempty"`
	FilterType   NodeType `protobuf:"varint,6,opt,name=FilterType,enum=tree.NodeType" json:"FilterType,omitempty"`
}

func (m *ListNodesRequest) Reset()                    { *m = ListNodesRequest{} }
func (m *ListNodesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListNodesRequest) ProtoMessage()               {}
func (*ListNodesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ListNodesRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *ListNodesRequest) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

func (m *ListNodesRequest) GetAncestors() bool {
	if m != nil {
		return m.Ancestors
	}
	return false
}

func (m *ListNodesRequest) GetWithVersions() bool {
	if m != nil {
		return m.WithVersions
	}
	return false
}

func (m *ListNodesRequest) GetWithCommits() bool {
	if m != nil {
		return m.WithCommits
	}
	return false
}

func (m *ListNodesRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListNodesRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *ListNodesRequest) GetFilterType() NodeType {
	if m != nil {
		return m.FilterType
	}
	return NodeType_UNKNOWN
}

type ListNodesResponse struct {
	Node *Node `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
}

func (m *ListNodesResponse) Reset()                    { *m = ListNodesResponse{} }
func (m *ListNodesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListNodesResponse) ProtoMessage()               {}
func (*ListNodesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ListNodesResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

// Request / Responses Messages
type CreateNodeRequest struct {
	Node              *Node  `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
	UpdateIfExists    bool   `protobuf:"varint,2,opt,name=UpdateIfExists" json:"UpdateIfExists,omitempty"`
	IndexationSession string `protobuf:"bytes,3,opt,name=IndexationSession" json:"IndexationSession,omitempty"`
}

func (m *CreateNodeRequest) Reset()                    { *m = CreateNodeRequest{} }
func (m *CreateNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateNodeRequest) ProtoMessage()               {}
func (*CreateNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CreateNodeRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *CreateNodeRequest) GetUpdateIfExists() bool {
	if m != nil {
		return m.UpdateIfExists
	}
	return false
}

func (m *CreateNodeRequest) GetIndexationSession() string {
	if m != nil {
		return m.IndexationSession
	}
	return ""
}

type CreateNodeResponse struct {
	Success bool  `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	Node    *Node `protobuf:"bytes,2,opt,name=Node" json:"Node,omitempty"`
}

func (m *CreateNodeResponse) Reset()                    { *m = CreateNodeResponse{} }
func (m *CreateNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateNodeResponse) ProtoMessage()               {}
func (*CreateNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CreateNodeResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CreateNodeResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type UpdateNodeRequest struct {
	From              *Node  `protobuf:"bytes,1,opt,name=From" json:"From,omitempty"`
	To                *Node  `protobuf:"bytes,2,opt,name=To" json:"To,omitempty"`
	IndexationSession string `protobuf:"bytes,3,opt,name=IndexationSession" json:"IndexationSession,omitempty"`
}

func (m *UpdateNodeRequest) Reset()                    { *m = UpdateNodeRequest{} }
func (m *UpdateNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateNodeRequest) ProtoMessage()               {}
func (*UpdateNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *UpdateNodeRequest) GetFrom() *Node {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *UpdateNodeRequest) GetTo() *Node {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *UpdateNodeRequest) GetIndexationSession() string {
	if m != nil {
		return m.IndexationSession
	}
	return ""
}

type UpdateNodeResponse struct {
	Success bool  `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	Node    *Node `protobuf:"bytes,2,opt,name=Node" json:"Node,omitempty"`
}

func (m *UpdateNodeResponse) Reset()                    { *m = UpdateNodeResponse{} }
func (m *UpdateNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateNodeResponse) ProtoMessage()               {}
func (*UpdateNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UpdateNodeResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *UpdateNodeResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type DeleteNodeRequest struct {
	Node              *Node  `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
	IndexationSession string `protobuf:"bytes,2,opt,name=IndexationSession" json:"IndexationSession,omitempty"`
}

func (m *DeleteNodeRequest) Reset()                    { *m = DeleteNodeRequest{} }
func (m *DeleteNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteNodeRequest) ProtoMessage()               {}
func (*DeleteNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DeleteNodeRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *DeleteNodeRequest) GetIndexationSession() string {
	if m != nil {
		return m.IndexationSession
	}
	return ""
}

type DeleteNodeResponse struct {
	Success bool `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
}

func (m *DeleteNodeResponse) Reset()                    { *m = DeleteNodeResponse{} }
func (m *DeleteNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteNodeResponse) ProtoMessage()               {}
func (*DeleteNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DeleteNodeResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type IndexationSession struct {
	Uuid                    string `protobuf:"bytes,1,opt,name=Uuid" json:"Uuid,omitempty"`
	Description             string `protobuf:"bytes,2,opt,name=Description" json:"Description,omitempty"`
	RootNode                *Node  `protobuf:"bytes,3,opt,name=RootNode" json:"RootNode,omitempty"`
	ExpectedOperationsCount int64  `protobuf:"varint,4,opt,name=ExpectedOperationsCount" json:"ExpectedOperationsCount,omitempty"`
	CurrentOperationCount   int64  `protobuf:"varint,5,opt,name=CurrentOperationCount" json:"CurrentOperationCount,omitempty"`
}

func (m *IndexationSession) Reset()                    { *m = IndexationSession{} }
func (m *IndexationSession) String() string            { return proto.CompactTextString(m) }
func (*IndexationSession) ProtoMessage()               {}
func (*IndexationSession) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *IndexationSession) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *IndexationSession) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *IndexationSession) GetRootNode() *Node {
	if m != nil {
		return m.RootNode
	}
	return nil
}

func (m *IndexationSession) GetExpectedOperationsCount() int64 {
	if m != nil {
		return m.ExpectedOperationsCount
	}
	return 0
}

func (m *IndexationSession) GetCurrentOperationCount() int64 {
	if m != nil {
		return m.CurrentOperationCount
	}
	return 0
}

type IndexationOperation struct {
	SessionUuid string `protobuf:"bytes,1,opt,name=SessionUuid" json:"SessionUuid,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=Description" json:"Description,omitempty"`
	Cursor      int64  `protobuf:"varint,3,opt,name=Cursor" json:"Cursor,omitempty"`
}

func (m *IndexationOperation) Reset()                    { *m = IndexationOperation{} }
func (m *IndexationOperation) String() string            { return proto.CompactTextString(m) }
func (*IndexationOperation) ProtoMessage()               {}
func (*IndexationOperation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *IndexationOperation) GetSessionUuid() string {
	if m != nil {
		return m.SessionUuid
	}
	return ""
}

func (m *IndexationOperation) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *IndexationOperation) GetCursor() int64 {
	if m != nil {
		return m.Cursor
	}
	return 0
}

type OpenSessionRequest struct {
	Session *IndexationSession `protobuf:"bytes,1,opt,name=Session" json:"Session,omitempty"`
}

func (m *OpenSessionRequest) Reset()                    { *m = OpenSessionRequest{} }
func (m *OpenSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenSessionRequest) ProtoMessage()               {}
func (*OpenSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *OpenSessionRequest) GetSession() *IndexationSession {
	if m != nil {
		return m.Session
	}
	return nil
}

type OpenSessionResponse struct {
	Session *IndexationSession `protobuf:"bytes,1,opt,name=Session" json:"Session,omitempty"`
}

func (m *OpenSessionResponse) Reset()                    { *m = OpenSessionResponse{} }
func (m *OpenSessionResponse) String() string            { return proto.CompactTextString(m) }
func (*OpenSessionResponse) ProtoMessage()               {}
func (*OpenSessionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *OpenSessionResponse) GetSession() *IndexationSession {
	if m != nil {
		return m.Session
	}
	return nil
}

type FlushSessionRequest struct {
	Session *IndexationSession `protobuf:"bytes,1,opt,name=Session" json:"Session,omitempty"`
}

func (m *FlushSessionRequest) Reset()                    { *m = FlushSessionRequest{} }
func (m *FlushSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*FlushSessionRequest) ProtoMessage()               {}
func (*FlushSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *FlushSessionRequest) GetSession() *IndexationSession {
	if m != nil {
		return m.Session
	}
	return nil
}

type FlushSessionResponse struct {
	Session *IndexationSession `protobuf:"bytes,1,opt,name=Session" json:"Session,omitempty"`
}

func (m *FlushSessionResponse) Reset()                    { *m = FlushSessionResponse{} }
func (m *FlushSessionResponse) String() string            { return proto.CompactTextString(m) }
func (*FlushSessionResponse) ProtoMessage()               {}
func (*FlushSessionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *FlushSessionResponse) GetSession() *IndexationSession {
	if m != nil {
		return m.Session
	}
	return nil
}

type CloseSessionRequest struct {
	Session *IndexationSession `protobuf:"bytes,1,opt,name=Session" json:"Session,omitempty"`
}

func (m *CloseSessionRequest) Reset()                    { *m = CloseSessionRequest{} }
func (m *CloseSessionRequest) String() string            { return proto.CompactTextString(m) }
func (*CloseSessionRequest) ProtoMessage()               {}
func (*CloseSessionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *CloseSessionRequest) GetSession() *IndexationSession {
	if m != nil {
		return m.Session
	}
	return nil
}

type CloseSessionResponse struct {
	Session *IndexationSession `protobuf:"bytes,1,opt,name=Session" json:"Session,omitempty"`
}

func (m *CloseSessionResponse) Reset()                    { *m = CloseSessionResponse{} }
func (m *CloseSessionResponse) String() string            { return proto.CompactTextString(m) }
func (*CloseSessionResponse) ProtoMessage()               {}
func (*CloseSessionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *CloseSessionResponse) GetSession() *IndexationSession {
	if m != nil {
		return m.Session
	}
	return nil
}

// Request / Responses Messages
type WatchNodeRequest struct {
	Node *Node `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
}

func (m *WatchNodeRequest) Reset()                    { *m = WatchNodeRequest{} }
func (m *WatchNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchNodeRequest) ProtoMessage()               {}
func (*WatchNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *WatchNodeRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type WatchNodeResponse struct {
	Node *Node `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
}

func (m *WatchNodeResponse) Reset()                    { *m = WatchNodeResponse{} }
func (m *WatchNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*WatchNodeResponse) ProtoMessage()               {}
func (*WatchNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *WatchNodeResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type SearchRequest struct {
	// The query object
	Query *Query `protobuf:"bytes,1,opt,name=Query" json:"Query,omitempty"`
	// Limit the number of results
	Size int32 `protobuf:"varint,2,opt,name=Size" json:"Size,omitempty"`
	// Start at given position
	From int32 `protobuf:"varint,3,opt,name=From" json:"From,omitempty"`
	// Load node details
	Details bool `protobuf:"varint,4,opt,name=Details" json:"Details,omitempty"`
	// Facet search
	Facet string `protobuf:"bytes,5,opt,name=Facet" json:"Facet,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *SearchRequest) GetQuery() *Query {
	if m != nil {
		return m.Query
	}
	return nil
}

func (m *SearchRequest) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *SearchRequest) GetFrom() int32 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *SearchRequest) GetDetails() bool {
	if m != nil {
		return m.Details
	}
	return false
}

func (m *SearchRequest) GetFacet() string {
	if m != nil {
		return m.Facet
	}
	return ""
}

type SearchResponse struct {
	Node *Node `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *SearchResponse) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type CreateVersionRequest struct {
	Node         *Node            `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
	TriggerEvent *NodeChangeEvent `protobuf:"bytes,2,opt,name=TriggerEvent" json:"TriggerEvent,omitempty"`
}

func (m *CreateVersionRequest) Reset()                    { *m = CreateVersionRequest{} }
func (m *CreateVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateVersionRequest) ProtoMessage()               {}
func (*CreateVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *CreateVersionRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *CreateVersionRequest) GetTriggerEvent() *NodeChangeEvent {
	if m != nil {
		return m.TriggerEvent
	}
	return nil
}

type CreateVersionResponse struct {
	Version *ChangeLog `protobuf:"bytes,1,opt,name=Version" json:"Version,omitempty"`
}

func (m *CreateVersionResponse) Reset()                    { *m = CreateVersionResponse{} }
func (m *CreateVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateVersionResponse) ProtoMessage()               {}
func (*CreateVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *CreateVersionResponse) GetVersion() *ChangeLog {
	if m != nil {
		return m.Version
	}
	return nil
}

type ListVersionsRequest struct {
	Node *Node `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
}

func (m *ListVersionsRequest) Reset()                    { *m = ListVersionsRequest{} }
func (m *ListVersionsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListVersionsRequest) ProtoMessage()               {}
func (*ListVersionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ListVersionsRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type ListVersionsResponse struct {
	Version *ChangeLog `protobuf:"bytes,1,opt,name=Version" json:"Version,omitempty"`
}

func (m *ListVersionsResponse) Reset()                    { *m = ListVersionsResponse{} }
func (m *ListVersionsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListVersionsResponse) ProtoMessage()               {}
func (*ListVersionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ListVersionsResponse) GetVersion() *ChangeLog {
	if m != nil {
		return m.Version
	}
	return nil
}

type HeadVersionRequest struct {
	Node      *Node  `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
	VersionId string `protobuf:"bytes,2,opt,name=VersionId" json:"VersionId,omitempty"`
}

func (m *HeadVersionRequest) Reset()                    { *m = HeadVersionRequest{} }
func (m *HeadVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*HeadVersionRequest) ProtoMessage()               {}
func (*HeadVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *HeadVersionRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *HeadVersionRequest) GetVersionId() string {
	if m != nil {
		return m.VersionId
	}
	return ""
}

type HeadVersionResponse struct {
	Version *ChangeLog `protobuf:"bytes,1,opt,name=Version" json:"Version,omitempty"`
}

func (m *HeadVersionResponse) Reset()                    { *m = HeadVersionResponse{} }
func (m *HeadVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*HeadVersionResponse) ProtoMessage()               {}
func (*HeadVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *HeadVersionResponse) GetVersion() *ChangeLog {
	if m != nil {
		return m.Version
	}
	return nil
}

type StoreVersionRequest struct {
	Node    *Node      `protobuf:"bytes,1,opt,name=Node" json:"Node,omitempty"`
	Version *ChangeLog `protobuf:"bytes,2,opt,name=Version" json:"Version,omitempty"`
}

func (m *StoreVersionRequest) Reset()                    { *m = StoreVersionRequest{} }
func (m *StoreVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*StoreVersionRequest) ProtoMessage()               {}
func (*StoreVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *StoreVersionRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *StoreVersionRequest) GetVersion() *ChangeLog {
	if m != nil {
		return m.Version
	}
	return nil
}

type StoreVersionResponse struct {
	Success       bool         `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	PruneVersions []*ChangeLog `protobuf:"bytes,2,rep,name=PruneVersions" json:"PruneVersions,omitempty"`
}

func (m *StoreVersionResponse) Reset()                    { *m = StoreVersionResponse{} }
func (m *StoreVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*StoreVersionResponse) ProtoMessage()               {}
func (*StoreVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *StoreVersionResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *StoreVersionResponse) GetPruneVersions() []*ChangeLog {
	if m != nil {
		return m.PruneVersions
	}
	return nil
}

type PruneVersionsRequest struct {
	UniqueNode      *Node `protobuf:"bytes,1,opt,name=UniqueNode" json:"UniqueNode,omitempty"`
	AllDeletedNodes bool  `protobuf:"varint,2,opt,name=AllDeletedNodes" json:"AllDeletedNodes,omitempty"`
}

func (m *PruneVersionsRequest) Reset()                    { *m = PruneVersionsRequest{} }
func (m *PruneVersionsRequest) String() string            { return proto.CompactTextString(m) }
func (*PruneVersionsRequest) ProtoMessage()               {}
func (*PruneVersionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *PruneVersionsRequest) GetUniqueNode() *Node {
	if m != nil {
		return m.UniqueNode
	}
	return nil
}

func (m *PruneVersionsRequest) GetAllDeletedNodes() bool {
	if m != nil {
		return m.AllDeletedNodes
	}
	return false
}

type PruneVersionsResponse struct {
	DeletedVersions []string `protobuf:"bytes,1,rep,name=DeletedVersions" json:"DeletedVersions,omitempty"`
}

func (m *PruneVersionsResponse) Reset()                    { *m = PruneVersionsResponse{} }
func (m *PruneVersionsResponse) String() string            { return proto.CompactTextString(m) }
func (*PruneVersionsResponse) ProtoMessage()               {}
func (*PruneVersionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *PruneVersionsResponse) GetDeletedVersions() []string {
	if m != nil {
		return m.DeletedVersions
	}
	return nil
}

type VersioningPolicy struct {
	Uuid                     string                  `protobuf:"bytes,1,opt,name=Uuid" json:"Uuid,omitempty"`
	Name                     string                  `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	Description              string                  `protobuf:"bytes,3,opt,name=Description" json:"Description,omitempty"`
	VersionsDataSourceName   string                  `protobuf:"bytes,4,opt,name=VersionsDataSourceName" json:"VersionsDataSourceName,omitempty"`
	VersionsDataSourceBucket string                  `protobuf:"bytes,5,opt,name=VersionsDataSourceBucket" json:"VersionsDataSourceBucket,omitempty"`
	MaxTotalSize             int64                   `protobuf:"varint,6,opt,name=MaxTotalSize" json:"MaxTotalSize,omitempty"`
	MaxSizePerFile           int64                   `protobuf:"varint,7,opt,name=MaxSizePerFile" json:"MaxSizePerFile,omitempty"`
	IgnoreFilesGreaterThan   int64                   `protobuf:"varint,8,opt,name=IgnoreFilesGreaterThan" json:"IgnoreFilesGreaterThan,omitempty"`
	KeepPeriods              []*VersioningKeepPeriod `protobuf:"bytes,9,rep,name=KeepPeriods" json:"KeepPeriods,omitempty"`
}

func (m *VersioningPolicy) Reset()                    { *m = VersioningPolicy{} }
func (m *VersioningPolicy) String() string            { return proto.CompactTextString(m) }
func (*VersioningPolicy) ProtoMessage()               {}
func (*VersioningPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *VersioningPolicy) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *VersioningPolicy) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VersioningPolicy) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *VersioningPolicy) GetVersionsDataSourceName() string {
	if m != nil {
		return m.VersionsDataSourceName
	}
	return ""
}

func (m *VersioningPolicy) GetVersionsDataSourceBucket() string {
	if m != nil {
		return m.VersionsDataSourceBucket
	}
	return ""
}

func (m *VersioningPolicy) GetMaxTotalSize() int64 {
	if m != nil {
		return m.MaxTotalSize
	}
	return 0
}

func (m *VersioningPolicy) GetMaxSizePerFile() int64 {
	if m != nil {
		return m.MaxSizePerFile
	}
	return 0
}

func (m *VersioningPolicy) GetIgnoreFilesGreaterThan() int64 {
	if m != nil {
		return m.IgnoreFilesGreaterThan
	}
	return 0
}

func (m *VersioningPolicy) GetKeepPeriods() []*VersioningKeepPeriod {
	if m != nil {
		return m.KeepPeriods
	}
	return nil
}

type VersioningKeepPeriod struct {
	IntervalStart string `protobuf:"bytes,1,opt,name=IntervalStart" json:"IntervalStart,omitempty"`
	MaxNumber     int32  `protobuf:"varint,3,opt,name=MaxNumber" json:"MaxNumber,omitempty"`
}

func (m *VersioningKeepPeriod) Reset()                    { *m = VersioningKeepPeriod{} }
func (m *VersioningKeepPeriod) String() string            { return proto.CompactTextString(m) }
func (*VersioningKeepPeriod) ProtoMessage()               {}
func (*VersioningKeepPeriod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *VersioningKeepPeriod) GetIntervalStart() string {
	if m != nil {
		return m.IntervalStart
	}
	return ""
}

func (m *VersioningKeepPeriod) GetMaxNumber() int32 {
	if m != nil {
		return m.MaxNumber
	}
	return 0
}

type Node struct {
	// ------------------------------------
	// Core identification of the node
	// ------------------------------------
	Uuid string   `protobuf:"bytes,1,opt,name=Uuid" json:"Uuid,omitempty"`
	Path string   `protobuf:"bytes,2,opt,name=Path" json:"Path,omitempty"`
	Type NodeType `protobuf:"varint,3,opt,name=Type,enum=tree.NodeType" json:"Type,omitempty"`
	// Size of the file, or cumulated size of folder
	Size int64 `protobuf:"varint,4,opt,name=Size" json:"Size,omitempty"`
	// Last modification Timestamp
	MTime int64 `protobuf:"varint,5,opt,name=MTime" json:"MTime,omitempty"`
	// Permission mode, like 0777
	Mode int32 `protobuf:"varint,6,opt,name=Mode" json:"Mode,omitempty"`
	// Hash of the content if node is a LEAF, Uuid or
	Etag string `protobuf:"bytes,7,opt,name=Etag" json:"Etag,omitempty"`
	// List of successive commits
	Commits []*ChangeLog `protobuf:"bytes,9,rep,name=Commits" json:"Commits,omitempty"`
	// ------------------------------------
	// Then a free K => V representation of any kind of metadata
	// ------------------------------------
	MetaStore map[string]string `protobuf:"bytes,8,rep,name=MetaStore" json:"MetaStore,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Can be used for output when node is appearing in multiple workspaces
	AppearsIn []*WorkspaceRelativePath `protobuf:"bytes,10,rep,name=AppearsIn" json:"AppearsIn,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *Node) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Node) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Node) GetType() NodeType {
	if m != nil {
		return m.Type
	}
	return NodeType_UNKNOWN
}

func (m *Node) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Node) GetMTime() int64 {
	if m != nil {
		return m.MTime
	}
	return 0
}

func (m *Node) GetMode() int32 {
	if m != nil {
		return m.Mode
	}
	return 0
}

func (m *Node) GetEtag() string {
	if m != nil {
		return m.Etag
	}
	return ""
}

func (m *Node) GetCommits() []*ChangeLog {
	if m != nil {
		return m.Commits
	}
	return nil
}

func (m *Node) GetMetaStore() map[string]string {
	if m != nil {
		return m.MetaStore
	}
	return nil
}

func (m *Node) GetAppearsIn() []*WorkspaceRelativePath {
	if m != nil {
		return m.AppearsIn
	}
	return nil
}

// Used in AppearsIn to signal a node is
// appearing in multiple workspaces in the current context
type WorkspaceRelativePath struct {
	// Workspace Id
	WsUuid string `protobuf:"bytes,1,opt,name=WsUuid" json:"WsUuid,omitempty"`
	// Workspace Label
	WsLabel string `protobuf:"bytes,2,opt,name=WsLabel" json:"WsLabel,omitempty"`
	// Relative Path inside workspace
	Path string `protobuf:"bytes,3,opt,name=Path" json:"Path,omitempty"`
}

func (m *WorkspaceRelativePath) Reset()                    { *m = WorkspaceRelativePath{} }
func (m *WorkspaceRelativePath) String() string            { return proto.CompactTextString(m) }
func (*WorkspaceRelativePath) ProtoMessage()               {}
func (*WorkspaceRelativePath) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *WorkspaceRelativePath) GetWsUuid() string {
	if m != nil {
		return m.WsUuid
	}
	return ""
}

func (m *WorkspaceRelativePath) GetWsLabel() string {
	if m != nil {
		return m.WsLabel
	}
	return ""
}

func (m *WorkspaceRelativePath) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type ChangeLog struct {
	// Unique commit ID
	Uuid string `protobuf:"bytes,1,opt,name=Uuid" json:"Uuid,omitempty"`
	// Human-readable description of what happened
	Description string `protobuf:"bytes,2,opt,name=Description" json:"Description,omitempty"`
	// Unix Timestamp
	MTime int64 `protobuf:"varint,3,opt,name=MTime" json:"MTime,omitempty"`
	// Content Size at that moment
	Size int64 `protobuf:"varint,4,opt,name=Size" json:"Size,omitempty"`
	// Arbitrary additional data
	Data []byte `protobuf:"bytes,5,opt,name=Data,proto3" json:"Data,omitempty"`
	// Who performed this action
	OwnerUuid string `protobuf:"bytes,6,opt,name=OwnerUuid" json:"OwnerUuid,omitempty"`
	// Event that triggered this change
	Event *NodeChangeEvent `protobuf:"bytes,7,opt,name=Event" json:"Event,omitempty"`
}

func (m *ChangeLog) Reset()                    { *m = ChangeLog{} }
func (m *ChangeLog) String() string            { return proto.CompactTextString(m) }
func (*ChangeLog) ProtoMessage()               {}
func (*ChangeLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *ChangeLog) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ChangeLog) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ChangeLog) GetMTime() int64 {
	if m != nil {
		return m.MTime
	}
	return 0
}

func (m *ChangeLog) GetSize() int64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *ChangeLog) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ChangeLog) GetOwnerUuid() string {
	if m != nil {
		return m.OwnerUuid
	}
	return ""
}

func (m *ChangeLog) GetEvent() *NodeChangeEvent {
	if m != nil {
		return m.Event
	}
	return nil
}

// Search Queries
type Query struct {
	// Limit to a given subtree
	PathPrefix []string `protobuf:"bytes,1,rep,name=PathPrefix" json:"PathPrefix,omitempty"`
	// Range for size
	MinSize int64 `protobuf:"varint,2,opt,name=MinSize" json:"MinSize,omitempty"`
	MaxSize int64 `protobuf:"varint,3,opt,name=MaxSize" json:"MaxSize,omitempty"`
	// Range for date
	MinDate int64 `protobuf:"varint,4,opt,name=MinDate" json:"MinDate,omitempty"`
	MaxDate int64 `protobuf:"varint,5,opt,name=MaxDate" json:"MaxDate,omitempty"`
	// Limit to a given node type
	Type NodeType `protobuf:"varint,6,opt,name=Type,enum=tree.NodeType" json:"Type,omitempty"`
	// Search in filename
	FileName string `protobuf:"bytes,7,opt,name=FileName" json:"FileName,omitempty"`
	// Search in content
	Content string `protobuf:"bytes,8,opt,name=Content" json:"Content,omitempty"`
	// Free Query String (for metadata)
	FreeString string `protobuf:"bytes,9,opt,name=FreeString" json:"FreeString,omitempty"`
	// Search files by extension
	Extension string `protobuf:"bytes,10,opt,name=Extension" json:"Extension,omitempty"`
	// Search geographically
	GeoQuery *GeoQuery `protobuf:"bytes,11,opt,name=GeoQuery" json:"GeoQuery,omitempty"`
}

func (m *Query) Reset()                    { *m = Query{} }
func (m *Query) String() string            { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()               {}
func (*Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *Query) GetPathPrefix() []string {
	if m != nil {
		return m.PathPrefix
	}
	return nil
}

func (m *Query) GetMinSize() int64 {
	if m != nil {
		return m.MinSize
	}
	return 0
}

func (m *Query) GetMaxSize() int64 {
	if m != nil {
		return m.MaxSize
	}
	return 0
}

func (m *Query) GetMinDate() int64 {
	if m != nil {
		return m.MinDate
	}
	return 0
}

func (m *Query) GetMaxDate() int64 {
	if m != nil {
		return m.MaxDate
	}
	return 0
}

func (m *Query) GetType() NodeType {
	if m != nil {
		return m.Type
	}
	return NodeType_UNKNOWN
}

func (m *Query) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Query) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Query) GetFreeString() string {
	if m != nil {
		return m.FreeString
	}
	return ""
}

func (m *Query) GetExtension() string {
	if m != nil {
		return m.Extension
	}
	return ""
}

func (m *Query) GetGeoQuery() *GeoQuery {
	if m != nil {
		return m.GeoQuery
	}
	return nil
}

type GeoQuery struct {
	// Either use a center point and a distance
	Center *GeoPoint `protobuf:"bytes,1,opt,name=Center" json:"Center,omitempty"`
	// Example formats supported:
	// "5in" "5inch" "7yd" "7yards" "9ft" "9feet" "11km" "11kilometers"
	// "3nm" "3nauticalmiles" "13mm" "13millimeters" "15cm" "15centimeters"
	// "17mi" "17miles" "19m" "19meters"
	// If the unit cannot be determined, the entire string is parsed and the
	// unit of meters is assumed.
	Distance string `protobuf:"bytes,2,opt,name=Distance" json:"Distance,omitempty"`
	// Or use a bounding box with TopLeft and BottomRight points
	TopLeft     *GeoPoint `protobuf:"bytes,3,opt,name=TopLeft" json:"TopLeft,omitempty"`
	BottomRight *GeoPoint `protobuf:"bytes,4,opt,name=BottomRight" json:"BottomRight,omitempty"`
}

func (m *GeoQuery) Reset()                    { *m = GeoQuery{} }
func (m *GeoQuery) String() string            { return proto.CompactTextString(m) }
func (*GeoQuery) ProtoMessage()               {}
func (*GeoQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *GeoQuery) GetCenter() *GeoPoint {
	if m != nil {
		return m.Center
	}
	return nil
}

func (m *GeoQuery) GetDistance() string {
	if m != nil {
		return m.Distance
	}
	return ""
}

func (m *GeoQuery) GetTopLeft() *GeoPoint {
	if m != nil {
		return m.TopLeft
	}
	return nil
}

func (m *GeoQuery) GetBottomRight() *GeoPoint {
	if m != nil {
		return m.BottomRight
	}
	return nil
}

type GeoPoint struct {
	Lat float64 `protobuf:"fixed64,1,opt,name=Lat" json:"Lat,omitempty"`
	Lon float64 `protobuf:"fixed64,2,opt,name=Lon" json:"Lon,omitempty"`
}

func (m *GeoPoint) Reset()                    { *m = GeoPoint{} }
func (m *GeoPoint) String() string            { return proto.CompactTextString(m) }
func (*GeoPoint) ProtoMessage()               {}
func (*GeoPoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *GeoPoint) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *GeoPoint) GetLon() float64 {
	if m != nil {
		return m.Lon
	}
	return 0
}

type NodeChangeEvent struct {
	Type   NodeChangeEvent_EventType `protobuf:"varint,1,opt,name=Type,enum=tree.NodeChangeEvent_EventType" json:"Type,omitempty"`
	Source *Node                     `protobuf:"bytes,2,opt,name=Source" json:"Source,omitempty"`
	Target *Node                     `protobuf:"bytes,3,opt,name=Target" json:"Target,omitempty"`
}

func (m *NodeChangeEvent) Reset()                    { *m = NodeChangeEvent{} }
func (m *NodeChangeEvent) String() string            { return proto.CompactTextString(m) }
func (*NodeChangeEvent) ProtoMessage()               {}
func (*NodeChangeEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *NodeChangeEvent) GetType() NodeChangeEvent_EventType {
	if m != nil {
		return m.Type
	}
	return NodeChangeEvent_CREATE
}

func (m *NodeChangeEvent) GetSource() *Node {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *NodeChangeEvent) GetTarget() *Node {
	if m != nil {
		return m.Target
	}
	return nil
}

type GetEncryptionKeyRequest struct {
	User     string `protobuf:"bytes,1,opt,name=User" json:"User,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=Password" json:"Password,omitempty"`
	Node     *Node  `protobuf:"bytes,3,opt,name=Node" json:"Node,omitempty"`
	Create   bool   `protobuf:"varint,5,opt,name=Create" json:"Create,omitempty"`
}

func (m *GetEncryptionKeyRequest) Reset()                    { *m = GetEncryptionKeyRequest{} }
func (m *GetEncryptionKeyRequest) String() string            { return proto.CompactTextString(m) }
func (*GetEncryptionKeyRequest) ProtoMessage()               {}
func (*GetEncryptionKeyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *GetEncryptionKeyRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *GetEncryptionKeyRequest) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *GetEncryptionKeyRequest) GetNode() *Node {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *GetEncryptionKeyRequest) GetCreate() bool {
	if m != nil {
		return m.Create
	}
	return false
}

type GetEncryptionKeyResponse struct {
	Key []byte `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
}

func (m *GetEncryptionKeyResponse) Reset()                    { *m = GetEncryptionKeyResponse{} }
func (m *GetEncryptionKeyResponse) String() string            { return proto.CompactTextString(m) }
func (*GetEncryptionKeyResponse) ProtoMessage()               {}
func (*GetEncryptionKeyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *GetEncryptionKeyResponse) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type SyncChange struct {
	Seq    uint64          `protobuf:"varint,1,opt,name=seq" json:"seq,omitempty"`
	NodeId string          `protobuf:"bytes,2,opt,name=nodeId,json=node_id" json:"nodeId,omitempty"`
	Type   SyncChange_Type `protobuf:"varint,3,opt,name=type,enum=tree.SyncChange_Type" json:"type,omitempty"`
	Source string          `protobuf:"bytes,4,opt,name=source" json:"source,omitempty"`
	Target string          `protobuf:"bytes,5,opt,name=target" json:"target,omitempty"`
	Node   *SyncChangeNode `protobuf:"bytes,6,opt,name=node" json:"node,omitempty"`
}

func (m *SyncChange) Reset()                    { *m = SyncChange{} }
func (m *SyncChange) String() string            { return proto.CompactTextString(m) }
func (*SyncChange) ProtoMessage()               {}
func (*SyncChange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *SyncChange) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *SyncChange) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *SyncChange) GetType() SyncChange_Type {
	if m != nil {
		return m.Type
	}
	return SyncChange_unknown
}

func (m *SyncChange) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *SyncChange) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *SyncChange) GetNode() *SyncChangeNode {
	if m != nil {
		return m.Node
	}
	return nil
}

type SyncChangeNode struct {
	Bytesize             int64  `protobuf:"varint,1,opt,name=bytesize" json:"bytesize,omitempty"`
	Md5                  string `protobuf:"bytes,2,opt,name=md5" json:"md5,omitempty"`
	Mtime                int64  `protobuf:"varint,3,opt,name=mtime" json:"mtime,omitempty"`
	NodePath             string `protobuf:"bytes,4,opt,name=nodePath,json=node_path" json:"nodePath,omitempty"`
	RepositoryIdentifier string `protobuf:"bytes,5,opt,name=repositoryIdentifier,json=repository_identifier" json:"repositoryIdentifier,omitempty"`
}

func (m *SyncChangeNode) Reset()                    { *m = SyncChangeNode{} }
func (m *SyncChangeNode) String() string            { return proto.CompactTextString(m) }
func (*SyncChangeNode) ProtoMessage()               {}
func (*SyncChangeNode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *SyncChangeNode) GetBytesize() int64 {
	if m != nil {
		return m.Bytesize
	}
	return 0
}

func (m *SyncChangeNode) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *SyncChangeNode) GetMtime() int64 {
	if m != nil {
		return m.Mtime
	}
	return 0
}

func (m *SyncChangeNode) GetNodePath() string {
	if m != nil {
		return m.NodePath
	}
	return ""
}

func (m *SyncChangeNode) GetRepositoryIdentifier() string {
	if m != nil {
		return m.RepositoryIdentifier
	}
	return ""
}

type PutSyncChangeResponse struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Msg     string `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
}

func (m *PutSyncChangeResponse) Reset()                    { *m = PutSyncChangeResponse{} }
func (m *PutSyncChangeResponse) String() string            { return proto.CompactTextString(m) }
func (*PutSyncChangeResponse) ProtoMessage()               {}
func (*PutSyncChangeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *PutSyncChangeResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *PutSyncChangeResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type SearchSyncChangeRequest struct {
	Seq         uint64 `protobuf:"varint,1,opt,name=seq" json:"seq,omitempty"`
	Flatten     bool   `protobuf:"varint,2,opt,name=flatten" json:"flatten,omitempty"`
	Prefix      string `protobuf:"bytes,3,opt,name=prefix" json:"prefix,omitempty"`
	LastSeqOnly bool   `protobuf:"varint,4,opt,name=lastSeqOnly" json:"lastSeqOnly,omitempty"`
}

func (m *SearchSyncChangeRequest) Reset()                    { *m = SearchSyncChangeRequest{} }
func (m *SearchSyncChangeRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchSyncChangeRequest) ProtoMessage()               {}
func (*SearchSyncChangeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *SearchSyncChangeRequest) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *SearchSyncChangeRequest) GetFlatten() bool {
	if m != nil {
		return m.Flatten
	}
	return false
}

func (m *SearchSyncChangeRequest) GetPrefix() string {
	if m != nil {
		return m.Prefix
	}
	return ""
}

func (m *SearchSyncChangeRequest) GetLastSeqOnly() bool {
	if m != nil {
		return m.LastSeqOnly
	}
	return false
}

func init() {
	proto.RegisterType((*ReadNodeRequest)(nil), "tree.ReadNodeRequest")
	proto.RegisterType((*ReadNodeResponse)(nil), "tree.ReadNodeResponse")
	proto.RegisterType((*ListNodesRequest)(nil), "tree.ListNodesRequest")
	proto.RegisterType((*ListNodesResponse)(nil), "tree.ListNodesResponse")
	proto.RegisterType((*CreateNodeRequest)(nil), "tree.CreateNodeRequest")
	proto.RegisterType((*CreateNodeResponse)(nil), "tree.CreateNodeResponse")
	proto.RegisterType((*UpdateNodeRequest)(nil), "tree.UpdateNodeRequest")
	proto.RegisterType((*UpdateNodeResponse)(nil), "tree.UpdateNodeResponse")
	proto.RegisterType((*DeleteNodeRequest)(nil), "tree.DeleteNodeRequest")
	proto.RegisterType((*DeleteNodeResponse)(nil), "tree.DeleteNodeResponse")
	proto.RegisterType((*IndexationSession)(nil), "tree.IndexationSession")
	proto.RegisterType((*IndexationOperation)(nil), "tree.IndexationOperation")
	proto.RegisterType((*OpenSessionRequest)(nil), "tree.OpenSessionRequest")
	proto.RegisterType((*OpenSessionResponse)(nil), "tree.OpenSessionResponse")
	proto.RegisterType((*FlushSessionRequest)(nil), "tree.FlushSessionRequest")
	proto.RegisterType((*FlushSessionResponse)(nil), "tree.FlushSessionResponse")
	proto.RegisterType((*CloseSessionRequest)(nil), "tree.CloseSessionRequest")
	proto.RegisterType((*CloseSessionResponse)(nil), "tree.CloseSessionResponse")
	proto.RegisterType((*WatchNodeRequest)(nil), "tree.WatchNodeRequest")
	proto.RegisterType((*WatchNodeResponse)(nil), "tree.WatchNodeResponse")
	proto.RegisterType((*SearchRequest)(nil), "tree.SearchRequest")
	proto.RegisterType((*SearchResponse)(nil), "tree.SearchResponse")
	proto.RegisterType((*CreateVersionRequest)(nil), "tree.CreateVersionRequest")
	proto.RegisterType((*CreateVersionResponse)(nil), "tree.CreateVersionResponse")
	proto.RegisterType((*ListVersionsRequest)(nil), "tree.ListVersionsRequest")
	proto.RegisterType((*ListVersionsResponse)(nil), "tree.ListVersionsResponse")
	proto.RegisterType((*HeadVersionRequest)(nil), "tree.HeadVersionRequest")
	proto.RegisterType((*HeadVersionResponse)(nil), "tree.HeadVersionResponse")
	proto.RegisterType((*StoreVersionRequest)(nil), "tree.StoreVersionRequest")
	proto.RegisterType((*StoreVersionResponse)(nil), "tree.StoreVersionResponse")
	proto.RegisterType((*PruneVersionsRequest)(nil), "tree.PruneVersionsRequest")
	proto.RegisterType((*PruneVersionsResponse)(nil), "tree.PruneVersionsResponse")
	proto.RegisterType((*VersioningPolicy)(nil), "tree.VersioningPolicy")
	proto.RegisterType((*VersioningKeepPeriod)(nil), "tree.VersioningKeepPeriod")
	proto.RegisterType((*Node)(nil), "tree.Node")
	proto.RegisterType((*WorkspaceRelativePath)(nil), "tree.WorkspaceRelativePath")
	proto.RegisterType((*ChangeLog)(nil), "tree.ChangeLog")
	proto.RegisterType((*Query)(nil), "tree.Query")
	proto.RegisterType((*GeoQuery)(nil), "tree.GeoQuery")
	proto.RegisterType((*GeoPoint)(nil), "tree.GeoPoint")
	proto.RegisterType((*NodeChangeEvent)(nil), "tree.NodeChangeEvent")
	proto.RegisterType((*GetEncryptionKeyRequest)(nil), "tree.GetEncryptionKeyRequest")
	proto.RegisterType((*GetEncryptionKeyResponse)(nil), "tree.GetEncryptionKeyResponse")
	proto.RegisterType((*SyncChange)(nil), "tree.SyncChange")
	proto.RegisterType((*SyncChangeNode)(nil), "tree.SyncChangeNode")
	proto.RegisterType((*PutSyncChangeResponse)(nil), "tree.PutSyncChangeResponse")
	proto.RegisterType((*SearchSyncChangeRequest)(nil), "tree.SearchSyncChangeRequest")
	proto.RegisterEnum("tree.NodeType", NodeType_name, NodeType_value)
	proto.RegisterEnum("tree.NodeChangeEvent_EventType", NodeChangeEvent_EventType_name, NodeChangeEvent_EventType_value)
	proto.RegisterEnum("tree.SyncChange_Type", SyncChange_Type_name, SyncChange_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ client.Option
var _ server.Option

// Client API for NodeProvider service

type NodeProviderClient interface {
	ReadNode(ctx context.Context, in *ReadNodeRequest, opts ...client.CallOption) (*ReadNodeResponse, error)
	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...client.CallOption) (NodeProvider_ListNodesClient, error)
}

type nodeProviderClient struct {
	c           client.Client
	serviceName string
}

func NewNodeProviderClient(serviceName string, c client.Client) NodeProviderClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeProviderClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeProviderClient) ReadNode(ctx context.Context, in *ReadNodeRequest, opts ...client.CallOption) (*ReadNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeProvider.ReadNode", in)
	out := new(ReadNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeProviderClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...client.CallOption) (NodeProvider_ListNodesClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeProvider.ListNodes", &ListNodesRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &nodeProviderListNodesClient{stream}, nil
}

type NodeProvider_ListNodesClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*ListNodesResponse, error)
}

type nodeProviderListNodesClient struct {
	stream client.Streamer
}

func (x *nodeProviderListNodesClient) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderListNodesClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderListNodesClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderListNodesClient) Recv() (*ListNodesResponse, error) {
	m := new(ListNodesResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeProvider service

type NodeProviderHandler interface {
	ReadNode(context.Context, *ReadNodeRequest, *ReadNodeResponse) error
	ListNodes(context.Context, *ListNodesRequest, NodeProvider_ListNodesStream) error
}

func RegisterNodeProviderHandler(s server.Server, hdlr NodeProviderHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeProvider{hdlr}, opts...))
}

type NodeProvider struct {
	NodeProviderHandler
}

func (h *NodeProvider) ReadNode(ctx context.Context, in *ReadNodeRequest, out *ReadNodeResponse) error {
	return h.NodeProviderHandler.ReadNode(ctx, in, out)
}

func (h *NodeProvider) ListNodes(ctx context.Context, stream server.Streamer) error {
	m := new(ListNodesRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.NodeProviderHandler.ListNodes(ctx, m, &nodeProviderListNodesStream{stream})
}

type NodeProvider_ListNodesStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ListNodesResponse) error
}

type nodeProviderListNodesStream struct {
	stream server.Streamer
}

func (x *nodeProviderListNodesStream) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderListNodesStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderListNodesStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderListNodesStream) Send(m *ListNodesResponse) error {
	return x.stream.Send(m)
}

// Client API for NodeProviderStreamer service

type NodeProviderStreamerClient interface {
	ReadNodeStream(ctx context.Context, opts ...client.CallOption) (NodeProviderStreamer_ReadNodeStreamClient, error)
}

type nodeProviderStreamerClient struct {
	c           client.Client
	serviceName string
}

func NewNodeProviderStreamerClient(serviceName string, c client.Client) NodeProviderStreamerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeProviderStreamerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeProviderStreamerClient) ReadNodeStream(ctx context.Context, opts ...client.CallOption) (NodeProviderStreamer_ReadNodeStreamClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeProviderStreamer.ReadNodeStream", &ReadNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &nodeProviderStreamerReadNodeStreamClient{stream}, nil
}

type NodeProviderStreamer_ReadNodeStreamClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ReadNodeRequest) error
	Recv() (*ReadNodeResponse, error)
}

type nodeProviderStreamerReadNodeStreamClient struct {
	stream client.Streamer
}

func (x *nodeProviderStreamerReadNodeStreamClient) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderStreamerReadNodeStreamClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderStreamerReadNodeStreamClient) Send(m *ReadNodeRequest) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamClient) Recv() (*ReadNodeResponse, error) {
	m := new(ReadNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeProviderStreamer service

type NodeProviderStreamerHandler interface {
	ReadNodeStream(context.Context, NodeProviderStreamer_ReadNodeStreamStream) error
}

func RegisterNodeProviderStreamerHandler(s server.Server, hdlr NodeProviderStreamerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeProviderStreamer{hdlr}, opts...))
}

type NodeProviderStreamer struct {
	NodeProviderStreamerHandler
}

func (h *NodeProviderStreamer) ReadNodeStream(ctx context.Context, stream server.Streamer) error {
	return h.NodeProviderStreamerHandler.ReadNodeStream(ctx, &nodeProviderStreamerReadNodeStreamStream{stream})
}

type NodeProviderStreamer_ReadNodeStreamStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ReadNodeResponse) error
	Recv() (*ReadNodeRequest, error)
}

type nodeProviderStreamerReadNodeStreamStream struct {
	stream server.Streamer
}

func (x *nodeProviderStreamerReadNodeStreamStream) Close() error {
	return x.stream.Close()
}

func (x *nodeProviderStreamerReadNodeStreamStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeProviderStreamerReadNodeStreamStream) Send(m *ReadNodeResponse) error {
	return x.stream.Send(m)
}

func (x *nodeProviderStreamerReadNodeStreamStream) Recv() (*ReadNodeRequest, error) {
	m := new(ReadNodeRequest)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Client API for NodeReceiver service

type NodeReceiverClient interface {
	CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...client.CallOption) (*CreateNodeResponse, error)
	UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...client.CallOption) (*UpdateNodeResponse, error)
	DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...client.CallOption) (*DeleteNodeResponse, error)
}

type nodeReceiverClient struct {
	c           client.Client
	serviceName string
}

func NewNodeReceiverClient(serviceName string, c client.Client) NodeReceiverClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeReceiverClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeReceiverClient) CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...client.CallOption) (*CreateNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiver.CreateNode", in)
	out := new(CreateNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeReceiverClient) UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...client.CallOption) (*UpdateNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiver.UpdateNode", in)
	out := new(UpdateNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeReceiverClient) DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...client.CallOption) (*DeleteNodeResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiver.DeleteNode", in)
	out := new(DeleteNodeResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NodeReceiver service

type NodeReceiverHandler interface {
	CreateNode(context.Context, *CreateNodeRequest, *CreateNodeResponse) error
	UpdateNode(context.Context, *UpdateNodeRequest, *UpdateNodeResponse) error
	DeleteNode(context.Context, *DeleteNodeRequest, *DeleteNodeResponse) error
}

func RegisterNodeReceiverHandler(s server.Server, hdlr NodeReceiverHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeReceiver{hdlr}, opts...))
}

type NodeReceiver struct {
	NodeReceiverHandler
}

func (h *NodeReceiver) CreateNode(ctx context.Context, in *CreateNodeRequest, out *CreateNodeResponse) error {
	return h.NodeReceiverHandler.CreateNode(ctx, in, out)
}

func (h *NodeReceiver) UpdateNode(ctx context.Context, in *UpdateNodeRequest, out *UpdateNodeResponse) error {
	return h.NodeReceiverHandler.UpdateNode(ctx, in, out)
}

func (h *NodeReceiver) DeleteNode(ctx context.Context, in *DeleteNodeRequest, out *DeleteNodeResponse) error {
	return h.NodeReceiverHandler.DeleteNode(ctx, in, out)
}

// Client API for NodeReceiverStream service

type NodeReceiverStreamClient interface {
	CreateNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_CreateNodeStreamClient, error)
	UpdateNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_UpdateNodeStreamClient, error)
	DeleteNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_DeleteNodeStreamClient, error)
}

type nodeReceiverStreamClient struct {
	c           client.Client
	serviceName string
}

func NewNodeReceiverStreamClient(serviceName string, c client.Client) NodeReceiverStreamClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeReceiverStreamClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeReceiverStreamClient) CreateNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_CreateNodeStreamClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiverStream.CreateNodeStream", &CreateNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &nodeReceiverStreamCreateNodeStreamClient{stream}, nil
}

type NodeReceiverStream_CreateNodeStreamClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*CreateNodeRequest) error
	Recv() (*CreateNodeResponse, error)
}

type nodeReceiverStreamCreateNodeStreamClient struct {
	stream client.Streamer
}

func (x *nodeReceiverStreamCreateNodeStreamClient) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamCreateNodeStreamClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamCreateNodeStreamClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamCreateNodeStreamClient) Send(m *CreateNodeRequest) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamCreateNodeStreamClient) Recv() (*CreateNodeResponse, error) {
	m := new(CreateNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeReceiverStreamClient) UpdateNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_UpdateNodeStreamClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiverStream.UpdateNodeStream", &UpdateNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &nodeReceiverStreamUpdateNodeStreamClient{stream}, nil
}

type NodeReceiverStream_UpdateNodeStreamClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*UpdateNodeRequest) error
	Recv() (*UpdateNodeResponse, error)
}

type nodeReceiverStreamUpdateNodeStreamClient struct {
	stream client.Streamer
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) Send(m *UpdateNodeRequest) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamClient) Recv() (*UpdateNodeResponse, error) {
	m := new(UpdateNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeReceiverStreamClient) DeleteNodeStream(ctx context.Context, opts ...client.CallOption) (NodeReceiverStream_DeleteNodeStreamClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeReceiverStream.DeleteNodeStream", &DeleteNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &nodeReceiverStreamDeleteNodeStreamClient{stream}, nil
}

type NodeReceiverStream_DeleteNodeStreamClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*DeleteNodeRequest) error
	Recv() (*DeleteNodeResponse, error)
}

type nodeReceiverStreamDeleteNodeStreamClient struct {
	stream client.Streamer
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) Send(m *DeleteNodeRequest) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamClient) Recv() (*DeleteNodeResponse, error) {
	m := new(DeleteNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeReceiverStream service

type NodeReceiverStreamHandler interface {
	CreateNodeStream(context.Context, NodeReceiverStream_CreateNodeStreamStream) error
	UpdateNodeStream(context.Context, NodeReceiverStream_UpdateNodeStreamStream) error
	DeleteNodeStream(context.Context, NodeReceiverStream_DeleteNodeStreamStream) error
}

func RegisterNodeReceiverStreamHandler(s server.Server, hdlr NodeReceiverStreamHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeReceiverStream{hdlr}, opts...))
}

type NodeReceiverStream struct {
	NodeReceiverStreamHandler
}

func (h *NodeReceiverStream) CreateNodeStream(ctx context.Context, stream server.Streamer) error {
	return h.NodeReceiverStreamHandler.CreateNodeStream(ctx, &nodeReceiverStreamCreateNodeStreamStream{stream})
}

type NodeReceiverStream_CreateNodeStreamStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*CreateNodeResponse) error
	Recv() (*CreateNodeRequest, error)
}

type nodeReceiverStreamCreateNodeStreamStream struct {
	stream server.Streamer
}

func (x *nodeReceiverStreamCreateNodeStreamStream) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamCreateNodeStreamStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamCreateNodeStreamStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamCreateNodeStreamStream) Send(m *CreateNodeResponse) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamCreateNodeStreamStream) Recv() (*CreateNodeRequest, error) {
	m := new(CreateNodeRequest)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (h *NodeReceiverStream) UpdateNodeStream(ctx context.Context, stream server.Streamer) error {
	return h.NodeReceiverStreamHandler.UpdateNodeStream(ctx, &nodeReceiverStreamUpdateNodeStreamStream{stream})
}

type NodeReceiverStream_UpdateNodeStreamStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*UpdateNodeResponse) error
	Recv() (*UpdateNodeRequest, error)
}

type nodeReceiverStreamUpdateNodeStreamStream struct {
	stream server.Streamer
}

func (x *nodeReceiverStreamUpdateNodeStreamStream) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamUpdateNodeStreamStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamStream) Send(m *UpdateNodeResponse) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamUpdateNodeStreamStream) Recv() (*UpdateNodeRequest, error) {
	m := new(UpdateNodeRequest)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (h *NodeReceiverStream) DeleteNodeStream(ctx context.Context, stream server.Streamer) error {
	return h.NodeReceiverStreamHandler.DeleteNodeStream(ctx, &nodeReceiverStreamDeleteNodeStreamStream{stream})
}

type NodeReceiverStream_DeleteNodeStreamStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*DeleteNodeResponse) error
	Recv() (*DeleteNodeRequest, error)
}

type nodeReceiverStreamDeleteNodeStreamStream struct {
	stream server.Streamer
}

func (x *nodeReceiverStreamDeleteNodeStreamStream) Close() error {
	return x.stream.Close()
}

func (x *nodeReceiverStreamDeleteNodeStreamStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamStream) Send(m *DeleteNodeResponse) error {
	return x.stream.Send(m)
}

func (x *nodeReceiverStreamDeleteNodeStreamStream) Recv() (*DeleteNodeRequest, error) {
	m := new(DeleteNodeRequest)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Client API for SessionIndexer service

type SessionIndexerClient interface {
	OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...client.CallOption) (*OpenSessionResponse, error)
	FlushSession(ctx context.Context, in *FlushSessionRequest, opts ...client.CallOption) (*FlushSessionResponse, error)
	CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...client.CallOption) (*CloseSessionResponse, error)
}

type sessionIndexerClient struct {
	c           client.Client
	serviceName string
}

func NewSessionIndexerClient(serviceName string, c client.Client) SessionIndexerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &sessionIndexerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *sessionIndexerClient) OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...client.CallOption) (*OpenSessionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "SessionIndexer.OpenSession", in)
	out := new(OpenSessionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionIndexerClient) FlushSession(ctx context.Context, in *FlushSessionRequest, opts ...client.CallOption) (*FlushSessionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "SessionIndexer.FlushSession", in)
	out := new(FlushSessionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionIndexerClient) CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...client.CallOption) (*CloseSessionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "SessionIndexer.CloseSession", in)
	out := new(CloseSessionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SessionIndexer service

type SessionIndexerHandler interface {
	OpenSession(context.Context, *OpenSessionRequest, *OpenSessionResponse) error
	FlushSession(context.Context, *FlushSessionRequest, *FlushSessionResponse) error
	CloseSession(context.Context, *CloseSessionRequest, *CloseSessionResponse) error
}

func RegisterSessionIndexerHandler(s server.Server, hdlr SessionIndexerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&SessionIndexer{hdlr}, opts...))
}

type SessionIndexer struct {
	SessionIndexerHandler
}

func (h *SessionIndexer) OpenSession(ctx context.Context, in *OpenSessionRequest, out *OpenSessionResponse) error {
	return h.SessionIndexerHandler.OpenSession(ctx, in, out)
}

func (h *SessionIndexer) FlushSession(ctx context.Context, in *FlushSessionRequest, out *FlushSessionResponse) error {
	return h.SessionIndexerHandler.FlushSession(ctx, in, out)
}

func (h *SessionIndexer) CloseSession(ctx context.Context, in *CloseSessionRequest, out *CloseSessionResponse) error {
	return h.SessionIndexerHandler.CloseSession(ctx, in, out)
}

// Client API for NodeEventsProvider service

type NodeEventsProviderClient interface {
	WatchNode(ctx context.Context, in *WatchNodeRequest, opts ...client.CallOption) (NodeEventsProvider_WatchNodeClient, error)
}

type nodeEventsProviderClient struct {
	c           client.Client
	serviceName string
}

func NewNodeEventsProviderClient(serviceName string, c client.Client) NodeEventsProviderClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeEventsProviderClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeEventsProviderClient) WatchNode(ctx context.Context, in *WatchNodeRequest, opts ...client.CallOption) (NodeEventsProvider_WatchNodeClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeEventsProvider.WatchNode", &WatchNodeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &nodeEventsProviderWatchNodeClient{stream}, nil
}

type NodeEventsProvider_WatchNodeClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*WatchNodeResponse, error)
}

type nodeEventsProviderWatchNodeClient struct {
	stream client.Streamer
}

func (x *nodeEventsProviderWatchNodeClient) Close() error {
	return x.stream.Close()
}

func (x *nodeEventsProviderWatchNodeClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeEventsProviderWatchNodeClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeEventsProviderWatchNodeClient) Recv() (*WatchNodeResponse, error) {
	m := new(WatchNodeResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for NodeEventsProvider service

type NodeEventsProviderHandler interface {
	WatchNode(context.Context, *WatchNodeRequest, NodeEventsProvider_WatchNodeStream) error
}

func RegisterNodeEventsProviderHandler(s server.Server, hdlr NodeEventsProviderHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeEventsProvider{hdlr}, opts...))
}

type NodeEventsProvider struct {
	NodeEventsProviderHandler
}

func (h *NodeEventsProvider) WatchNode(ctx context.Context, stream server.Streamer) error {
	m := new(WatchNodeRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.NodeEventsProviderHandler.WatchNode(ctx, m, &nodeEventsProviderWatchNodeStream{stream})
}

type NodeEventsProvider_WatchNodeStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*WatchNodeResponse) error
}

type nodeEventsProviderWatchNodeStream struct {
	stream server.Streamer
}

func (x *nodeEventsProviderWatchNodeStream) Close() error {
	return x.stream.Close()
}

func (x *nodeEventsProviderWatchNodeStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeEventsProviderWatchNodeStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeEventsProviderWatchNodeStream) Send(m *WatchNodeResponse) error {
	return x.stream.Send(m)
}

// Client API for Searcher service

type SearcherClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...client.CallOption) (Searcher_SearchClient, error)
}

type searcherClient struct {
	c           client.Client
	serviceName string
}

func NewSearcherClient(serviceName string, c client.Client) SearcherClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &searcherClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *searcherClient) Search(ctx context.Context, in *SearchRequest, opts ...client.CallOption) (Searcher_SearchClient, error) {
	req := c.c.NewRequest(c.serviceName, "Searcher.Search", &SearchRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &searcherSearchClient{stream}, nil
}

type Searcher_SearchClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*SearchResponse, error)
}

type searcherSearchClient struct {
	stream client.Streamer
}

func (x *searcherSearchClient) Close() error {
	return x.stream.Close()
}

func (x *searcherSearchClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *searcherSearchClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *searcherSearchClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Searcher service

type SearcherHandler interface {
	Search(context.Context, *SearchRequest, Searcher_SearchStream) error
}

func RegisterSearcherHandler(s server.Server, hdlr SearcherHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&Searcher{hdlr}, opts...))
}

type Searcher struct {
	SearcherHandler
}

func (h *Searcher) Search(ctx context.Context, stream server.Streamer) error {
	m := new(SearchRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.SearcherHandler.Search(ctx, m, &searcherSearchStream{stream})
}

type Searcher_SearchStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*SearchResponse) error
}

type searcherSearchStream struct {
	stream server.Streamer
}

func (x *searcherSearchStream) Close() error {
	return x.stream.Close()
}

func (x *searcherSearchStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *searcherSearchStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *searcherSearchStream) Send(m *SearchResponse) error {
	return x.stream.Send(m)
}

// Client API for NodeContentReader service

type NodeContentReaderClient interface {
}

type nodeContentReaderClient struct {
	c           client.Client
	serviceName string
}

func NewNodeContentReaderClient(serviceName string, c client.Client) NodeContentReaderClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeContentReaderClient{
		c:           c,
		serviceName: serviceName,
	}
}

// Server API for NodeContentReader service

type NodeContentReaderHandler interface {
}

func RegisterNodeContentReaderHandler(s server.Server, hdlr NodeContentReaderHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeContentReader{hdlr}, opts...))
}

type NodeContentReader struct {
	NodeContentReaderHandler
}

// Client API for NodeContentWriter service

type NodeContentWriterClient interface {
}

type nodeContentWriterClient struct {
	c           client.Client
	serviceName string
}

func NewNodeContentWriterClient(serviceName string, c client.Client) NodeContentWriterClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeContentWriterClient{
		c:           c,
		serviceName: serviceName,
	}
}

// Server API for NodeContentWriter service

type NodeContentWriterHandler interface {
}

func RegisterNodeContentWriterHandler(s server.Server, hdlr NodeContentWriterHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeContentWriter{hdlr}, opts...))
}

type NodeContentWriter struct {
	NodeContentWriterHandler
}

// Client API for NodeVersioner service

type NodeVersionerClient interface {
	CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...client.CallOption) (*CreateVersionResponse, error)
	StoreVersion(ctx context.Context, in *StoreVersionRequest, opts ...client.CallOption) (*StoreVersionResponse, error)
	ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...client.CallOption) (NodeVersioner_ListVersionsClient, error)
	HeadVersion(ctx context.Context, in *HeadVersionRequest, opts ...client.CallOption) (*HeadVersionResponse, error)
	PruneVersions(ctx context.Context, in *PruneVersionsRequest, opts ...client.CallOption) (*PruneVersionsResponse, error)
}

type nodeVersionerClient struct {
	c           client.Client
	serviceName string
}

func NewNodeVersionerClient(serviceName string, c client.Client) NodeVersionerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &nodeVersionerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *nodeVersionerClient) CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...client.CallOption) (*CreateVersionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.CreateVersion", in)
	out := new(CreateVersionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) StoreVersion(ctx context.Context, in *StoreVersionRequest, opts ...client.CallOption) (*StoreVersionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.StoreVersion", in)
	out := new(StoreVersionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...client.CallOption) (NodeVersioner_ListVersionsClient, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.ListVersions", &ListVersionsRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &nodeVersionerListVersionsClient{stream}, nil
}

type NodeVersioner_ListVersionsClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*ListVersionsResponse, error)
}

type nodeVersionerListVersionsClient struct {
	stream client.Streamer
}

func (x *nodeVersionerListVersionsClient) Close() error {
	return x.stream.Close()
}

func (x *nodeVersionerListVersionsClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeVersionerListVersionsClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeVersionerListVersionsClient) Recv() (*ListVersionsResponse, error) {
	m := new(ListVersionsResponse)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeVersionerClient) HeadVersion(ctx context.Context, in *HeadVersionRequest, opts ...client.CallOption) (*HeadVersionResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.HeadVersion", in)
	out := new(HeadVersionResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeVersionerClient) PruneVersions(ctx context.Context, in *PruneVersionsRequest, opts ...client.CallOption) (*PruneVersionsResponse, error) {
	req := c.c.NewRequest(c.serviceName, "NodeVersioner.PruneVersions", in)
	out := new(PruneVersionsResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NodeVersioner service

type NodeVersionerHandler interface {
	CreateVersion(context.Context, *CreateVersionRequest, *CreateVersionResponse) error
	StoreVersion(context.Context, *StoreVersionRequest, *StoreVersionResponse) error
	ListVersions(context.Context, *ListVersionsRequest, NodeVersioner_ListVersionsStream) error
	HeadVersion(context.Context, *HeadVersionRequest, *HeadVersionResponse) error
	PruneVersions(context.Context, *PruneVersionsRequest, *PruneVersionsResponse) error
}

func RegisterNodeVersionerHandler(s server.Server, hdlr NodeVersionerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&NodeVersioner{hdlr}, opts...))
}

type NodeVersioner struct {
	NodeVersionerHandler
}

func (h *NodeVersioner) CreateVersion(ctx context.Context, in *CreateVersionRequest, out *CreateVersionResponse) error {
	return h.NodeVersionerHandler.CreateVersion(ctx, in, out)
}

func (h *NodeVersioner) StoreVersion(ctx context.Context, in *StoreVersionRequest, out *StoreVersionResponse) error {
	return h.NodeVersionerHandler.StoreVersion(ctx, in, out)
}

func (h *NodeVersioner) ListVersions(ctx context.Context, stream server.Streamer) error {
	m := new(ListVersionsRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.NodeVersionerHandler.ListVersions(ctx, m, &nodeVersionerListVersionsStream{stream})
}

type NodeVersioner_ListVersionsStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*ListVersionsResponse) error
}

type nodeVersionerListVersionsStream struct {
	stream server.Streamer
}

func (x *nodeVersionerListVersionsStream) Close() error {
	return x.stream.Close()
}

func (x *nodeVersionerListVersionsStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *nodeVersionerListVersionsStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *nodeVersionerListVersionsStream) Send(m *ListVersionsResponse) error {
	return x.stream.Send(m)
}

func (h *NodeVersioner) HeadVersion(ctx context.Context, in *HeadVersionRequest, out *HeadVersionResponse) error {
	return h.NodeVersionerHandler.HeadVersion(ctx, in, out)
}

func (h *NodeVersioner) PruneVersions(ctx context.Context, in *PruneVersionsRequest, out *PruneVersionsResponse) error {
	return h.NodeVersionerHandler.PruneVersions(ctx, in, out)
}

// Client API for FileKeyManager service

type FileKeyManagerClient interface {
	GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, opts ...client.CallOption) (*GetEncryptionKeyResponse, error)
}

type fileKeyManagerClient struct {
	c           client.Client
	serviceName string
}

func NewFileKeyManagerClient(serviceName string, c client.Client) FileKeyManagerClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &fileKeyManagerClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *fileKeyManagerClient) GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, opts ...client.CallOption) (*GetEncryptionKeyResponse, error) {
	req := c.c.NewRequest(c.serviceName, "FileKeyManager.GetEncryptionKey", in)
	out := new(GetEncryptionKeyResponse)
	err := c.c.Call(ctx, req, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileKeyManager service

type FileKeyManagerHandler interface {
	GetEncryptionKey(context.Context, *GetEncryptionKeyRequest, *GetEncryptionKeyResponse) error
}

func RegisterFileKeyManagerHandler(s server.Server, hdlr FileKeyManagerHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&FileKeyManager{hdlr}, opts...))
}

type FileKeyManager struct {
	FileKeyManagerHandler
}

func (h *FileKeyManager) GetEncryptionKey(ctx context.Context, in *GetEncryptionKeyRequest, out *GetEncryptionKeyResponse) error {
	return h.FileKeyManagerHandler.GetEncryptionKey(ctx, in, out)
}

// Client API for SyncChanges service

type SyncChangesClient interface {
	Put(ctx context.Context, opts ...client.CallOption) (SyncChanges_PutClient, error)
	Search(ctx context.Context, in *SearchSyncChangeRequest, opts ...client.CallOption) (SyncChanges_SearchClient, error)
}

type syncChangesClient struct {
	c           client.Client
	serviceName string
}

func NewSyncChangesClient(serviceName string, c client.Client) SyncChangesClient {
	if c == nil {
		c = client.NewClient()
	}
	if len(serviceName) == 0 {
		serviceName = "tree"
	}
	return &syncChangesClient{
		c:           c,
		serviceName: serviceName,
	}
}

func (c *syncChangesClient) Put(ctx context.Context, opts ...client.CallOption) (SyncChanges_PutClient, error) {
	req := c.c.NewRequest(c.serviceName, "SyncChanges.Put", &SyncChange{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return &syncChangesPutClient{stream}, nil
}

type SyncChanges_PutClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*SyncChange) error
}

type syncChangesPutClient struct {
	stream client.Streamer
}

func (x *syncChangesPutClient) Close() error {
	return x.stream.Close()
}

func (x *syncChangesPutClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *syncChangesPutClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *syncChangesPutClient) Send(m *SyncChange) error {
	return x.stream.Send(m)
}

func (c *syncChangesClient) Search(ctx context.Context, in *SearchSyncChangeRequest, opts ...client.CallOption) (SyncChanges_SearchClient, error) {
	req := c.c.NewRequest(c.serviceName, "SyncChanges.Search", &SearchSyncChangeRequest{})
	stream, err := c.c.Stream(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	if err := stream.Send(in); err != nil {
		return nil, err
	}
	return &syncChangesSearchClient{stream}, nil
}

type SyncChanges_SearchClient interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*SyncChange, error)
}

type syncChangesSearchClient struct {
	stream client.Streamer
}

func (x *syncChangesSearchClient) Close() error {
	return x.stream.Close()
}

func (x *syncChangesSearchClient) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *syncChangesSearchClient) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *syncChangesSearchClient) Recv() (*SyncChange, error) {
	m := new(SyncChange)
	err := x.stream.Recv(m)
	if err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SyncChanges service

type SyncChangesHandler interface {
	Put(context.Context, SyncChanges_PutStream) error
	Search(context.Context, *SearchSyncChangeRequest, SyncChanges_SearchStream) error
}

func RegisterSyncChangesHandler(s server.Server, hdlr SyncChangesHandler, opts ...server.HandlerOption) {
	s.Handle(s.NewHandler(&SyncChanges{hdlr}, opts...))
}

type SyncChanges struct {
	SyncChangesHandler
}

func (h *SyncChanges) Put(ctx context.Context, stream server.Streamer) error {
	return h.SyncChangesHandler.Put(ctx, &syncChangesPutStream{stream})
}

type SyncChanges_PutStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Recv() (*SyncChange, error)
}

type syncChangesPutStream struct {
	stream server.Streamer
}

func (x *syncChangesPutStream) Close() error {
	return x.stream.Close()
}

func (x *syncChangesPutStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *syncChangesPutStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *syncChangesPutStream) Recv() (*SyncChange, error) {
	m := new(SyncChange)
	if err := x.stream.Recv(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (h *SyncChanges) Search(ctx context.Context, stream server.Streamer) error {
	m := new(SearchSyncChangeRequest)
	if err := stream.Recv(m); err != nil {
		return err
	}
	return h.SyncChangesHandler.Search(ctx, m, &syncChangesSearchStream{stream})
}

type SyncChanges_SearchStream interface {
	SendMsg(interface{}) error
	RecvMsg(interface{}) error
	Close() error
	Send(*SyncChange) error
}

type syncChangesSearchStream struct {
	stream server.Streamer
}

func (x *syncChangesSearchStream) Close() error {
	return x.stream.Close()
}

func (x *syncChangesSearchStream) SendMsg(m interface{}) error {
	return x.stream.Send(m)
}

func (x *syncChangesSearchStream) RecvMsg(m interface{}) error {
	return x.stream.Recv(m)
}

func (x *syncChangesSearchStream) Send(m *SyncChange) error {
	return x.stream.Send(m)
}

func init() { proto.RegisterFile("tree.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2448 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x19, 0xcb, 0x6e, 0x1b, 0xd7,
	0x55, 0xc3, 0xa1, 0x28, 0xf2, 0x48, 0x96, 0x46, 0x57, 0x94, 0xc5, 0xd0, 0x89, 0xab, 0x0e, 0x0a,
	0x43, 0x71, 0x03, 0xc1, 0x91, 0xeb, 0xc6, 0x49, 0x53, 0xc0, 0x34, 0x45, 0xd9, 0xaa, 0x5e, 0xec,
	0x90, 0x8e, 0x80, 0x02, 0x81, 0x3b, 0x26, 0x8f, 0xa8, 0x81, 0xc9, 0x19, 0xea, 0xce, 0xa5, 0x2c,
	0x16, 0x28, 0x5a, 0x6f, 0x0a, 0xb4, 0x40, 0x37, 0xf9, 0x88, 0x2e, 0xfa, 0x29, 0xdd, 0x76, 0xd1,
	0x75, 0x77, 0xdd, 0x77, 0xd9, 0x4d, 0x71, 0x5f, 0xf3, 0x20, 0x47, 0xb1, 0x68, 0x67, 0x23, 0xcc,
	0x79, 0xdc, 0x73, 0xcf, 0xe3, 0x9e, 0x07, 0x8f, 0x00, 0x18, 0x45, 0xdc, 0x1e, 0xd2, 0x80, 0x05,
	0x24, 0xcf, 0xbf, 0xed, 0x16, 0xac, 0x38, 0xe8, 0x76, 0x8f, 0x83, 0x2e, 0x3a, 0x78, 0x31, 0xc2,
	0x90, 0x91, 0xbb, 0x90, 0xe7, 0x60, 0xc5, 0xd8, 0x34, 0xb6, 0x16, 0x77, 0x60, 0x5b, 0x9c, 0x11,
	0x0c, 0x02, 0x4f, 0x36, 0x61, 0xf1, 0xd4, 0x63, 0xe7, 0xf5, 0x60, 0x30, 0xf0, 0x58, 0x58, 0xc9,
	0x6d, 0x1a, 0x5b, 0x45, 0x27, 0x89, 0xb2, 0x0f, 0xc1, 0x8a, 0x85, 0x86, 0xc3, 0xc0, 0x0f, 0x91,
	0x54, 0x60, 0xa1, 0x35, 0xea, 0x74, 0x30, 0x0c, 0x85, 0xe0, 0xa2, 0xa3, 0xc1, 0xe8, 0xbe, 0x5c,
	0xf6, 0x7d, 0xf6, 0x77, 0x39, 0xb0, 0x0e, 0xbd, 0x90, 0x71, 0x20, 0xbc, 0xa9, 0x92, 0x1f, 0x43,
	0xc9, 0xc1, 0xce, 0x88, 0x86, 0xde, 0x25, 0x2a, 0x15, 0x63, 0x04, 0xa7, 0xd6, 0xfc, 0x0e, 0x86,
	0x2c, 0xa0, 0x61, 0xc5, 0x94, 0xd4, 0x08, 0x41, 0x6c, 0x58, 0xe2, 0xd6, 0x7c, 0x83, 0x34, 0xf4,
	0x02, 0x3f, 0xac, 0x2c, 0x08, 0x86, 0x14, 0x6e, 0xd2, 0x09, 0xc5, 0x29, 0x27, 0x90, 0x32, 0xcc,
	0x1f, 0x7a, 0x03, 0x8f, 0x55, 0xf2, 0x9b, 0xc6, 0x96, 0xe9, 0x48, 0x80, 0xdc, 0x86, 0xc2, 0xc9,
	0xd9, 0x59, 0x88, 0xac, 0x32, 0x2f, 0xd0, 0x0a, 0x22, 0xdb, 0x00, 0x7b, 0x5e, 0x9f, 0x21, 0x6d,
	0x8f, 0x87, 0x58, 0x29, 0x6c, 0x1a, 0x5b, 0xcb, 0x3b, 0xcb, 0xb1, 0x55, 0x1c, 0xeb, 0x24, 0x38,
	0xec, 0x87, 0xb0, 0x9a, 0xf0, 0x89, 0xf2, 0xf1, 0x3b, 0x9c, 0x62, 0xff, 0xd9, 0x80, 0xd5, 0x3a,
	0x45, 0x97, 0xe1, 0x2c, 0xf1, 0xbe, 0x07, 0xcb, 0x2f, 0x86, 0x5d, 0x97, 0xe1, 0xfe, 0x59, 0xe3,
	0xca, 0x0b, 0xa3, 0x90, 0x4f, 0x60, 0xc9, 0x67, 0xb0, 0xba, 0xef, 0x77, 0xf1, 0xca, 0x65, 0x5e,
	0xe0, 0xb7, 0x30, 0xe4, 0x8e, 0x12, 0xce, 0x2d, 0x39, 0xd3, 0x04, 0xfb, 0x18, 0x48, 0x52, 0x95,
	0x0f, 0x7e, 0x25, 0xbf, 0x87, 0x55, 0xa9, 0xcf, 0x84, 0x69, 0x7b, 0x34, 0x18, 0x64, 0x99, 0xc6,
	0xf1, 0xa4, 0x0a, 0xb9, 0x76, 0x90, 0x21, 0x32, 0xd7, 0x0e, 0x66, 0x37, 0x27, 0x79, 0xfd, 0x07,
	0x9b, 0xe3, 0xc2, 0xea, 0x2e, 0xf6, 0x71, 0xb6, 0x48, 0x65, 0xaa, 0x9c, 0xbb, 0x4e, 0xe5, 0x6d,
	0x20, 0xc9, 0x2b, 0xde, 0xa5, 0xb2, 0xfd, 0x6f, 0x23, 0x43, 0x3c, 0x21, 0x90, 0x7f, 0x31, 0xf2,
	0xba, 0x82, 0xb9, 0xe4, 0x88, 0x6f, 0x9e, 0x1c, 0xbb, 0x18, 0x76, 0xa8, 0x37, 0x64, 0xb1, 0x06,
	0x49, 0x14, 0xb9, 0x07, 0x45, 0x27, 0x08, 0xc4, 0xf3, 0x15, 0x3e, 0x4d, 0x5b, 0x13, 0xd1, 0xc8,
	0x63, 0xd8, 0x68, 0x5c, 0x0d, 0xb1, 0xc3, 0xb0, 0x7b, 0x32, 0x44, 0x2a, 0x6e, 0x0e, 0xeb, 0xc1,
	0xc8, 0xd7, 0x69, 0x75, 0x1d, 0x99, 0xfc, 0x0c, 0xd6, 0xeb, 0x23, 0x4a, 0xd1, 0x67, 0x11, 0x45,
	0x9e, 0x93, 0x79, 0x97, 0x4d, 0xb4, 0x2f, 0x60, 0x2d, 0x36, 0x31, 0xa2, 0x71, 0x83, 0x94, 0xbd,
	0x09, 0x5b, 0x93, 0xa8, 0x1b, 0x98, 0x7c, 0x1b, 0x0a, 0xf5, 0x11, 0x0d, 0x03, 0x2a, 0x0c, 0x36,
	0x1d, 0x05, 0xd9, 0xcf, 0x80, 0x9c, 0x0c, 0x51, 0xfb, 0x53, 0x87, 0xfa, 0x73, 0x58, 0xd0, 0x01,
	0x94, 0xd1, 0xde, 0x90, 0xfe, 0x99, 0x0a, 0x80, 0xa3, 0xf9, 0xec, 0xe7, 0xb0, 0x96, 0x12, 0xa4,
	0x02, 0xfa, 0x7e, 0x92, 0xf6, 0xfa, 0xa3, 0xf0, 0xfc, 0xc3, 0x75, 0xda, 0x87, 0x72, 0x5a, 0xd2,
	0x07, 0x29, 0x55, 0xef, 0x07, 0x21, 0xfe, 0x20, 0x4a, 0xa5, 0x25, 0xbd, 0xbf, 0x52, 0x3b, 0x60,
	0x9d, 0xba, 0xac, 0x73, 0x3e, 0x43, 0x96, 0xf2, 0xd2, 0x9d, 0x38, 0x73, 0xc3, 0xd2, 0xfd, 0x17,
	0x03, 0x6e, 0xb5, 0xd0, 0xa5, 0x9d, 0x73, 0x7d, 0xcd, 0x8f, 0x61, 0xfe, 0xd7, 0x23, 0xa4, 0x63,
	0x75, 0x64, 0x51, 0x1e, 0x11, 0x28, 0x47, 0x52, 0x78, 0x6e, 0xb6, 0xbc, 0xdf, 0xc9, 0x22, 0x33,
	0xef, 0x88, 0x6f, 0x8e, 0x13, 0x25, 0xd1, 0x94, 0x38, 0x51, 0x06, 0x2b, 0xb0, 0xb0, 0x8b, 0xcc,
	0xf5, 0xfa, 0xa1, 0xc8, 0xaa, 0xa2, 0xa3, 0x41, 0xde, 0xc4, 0xf6, 0xdc, 0x8e, 0xea, 0x56, 0x25,
	0x47, 0x02, 0xf6, 0x03, 0x58, 0xd6, 0xba, 0xdc, 0x50, 0xfd, 0x0b, 0x28, 0xcb, 0x6a, 0xaf, 0x1a,
	0xe8, 0x4d, 0x2b, 0xda, 0x97, 0xb0, 0xd4, 0xa6, 0x5e, 0xaf, 0x87, 0xb4, 0x71, 0x89, 0x3e, 0x53,
	0xe5, 0x72, 0x3d, 0xe6, 0xab, 0x9f, 0xbb, 0x7e, 0x0f, 0x05, 0xd1, 0x49, 0xb1, 0xda, 0x4f, 0x61,
	0x7d, 0xe2, 0x4a, 0xa5, 0xeb, 0xa7, 0xb0, 0xa0, 0x50, 0xea, 0xda, 0x15, 0x29, 0x4e, 0x8a, 0x3a,
	0x0c, 0x7a, 0x8e, 0xa6, 0xdb, 0x8f, 0x60, 0x8d, 0x77, 0x59, 0xdd, 0xf5, 0x6f, 0x1a, 0xe1, 0x1a,
	0x94, 0xd3, 0xc7, 0x66, 0xbf, 0xd9, 0x01, 0xf2, 0x1c, 0xdd, 0xee, 0x8c, 0xee, 0xfa, 0x18, 0x4a,
	0xea, 0xc4, 0x7e, 0x57, 0xd5, 0xa0, 0x18, 0x61, 0x3f, 0x81, 0xb5, 0x94, 0xcc, 0xd9, 0xb5, 0xfa,
	0x2d, 0xac, 0xb5, 0x58, 0x40, 0x67, 0x8d, 0x62, 0xe2, 0x86, 0xdc, 0x3b, 0x6e, 0xe8, 0x41, 0x39,
	0x7d, 0xc3, 0x3b, 0x3b, 0xe9, 0x23, 0xb8, 0xd5, 0xa4, 0x23, 0x1f, 0xa3, 0x71, 0x2d, 0xb7, 0x69,
	0x66, 0x5d, 0x91, 0xe6, 0xb2, 0xfb, 0x50, 0x4e, 0x21, 0xb4, 0x2d, 0xf7, 0x01, 0x5e, 0xf8, 0xde,
	0xc5, 0x08, 0xaf, 0xb1, 0x28, 0x41, 0x25, 0x5b, 0xb0, 0x52, 0xeb, 0xf7, 0x65, 0x13, 0x15, 0xd3,
	0xae, 0x1e, 0x8d, 0x26, 0xd1, 0x76, 0x0d, 0xd6, 0x27, 0x6e, 0x53, 0x76, 0x6d, 0xc1, 0x8a, 0x62,
	0x8c, 0xf4, 0x37, 0x36, 0xcd, 0xad, 0x92, 0x33, 0x89, 0xb6, 0xbf, 0x33, 0xc1, 0x52, 0x80, 0xe7,
	0xf7, 0x9a, 0x41, 0xdf, 0xeb, 0x8c, 0x33, 0xbb, 0x2f, 0x81, 0xfc, 0xb1, 0x3b, 0x40, 0x15, 0x7f,
	0xf1, 0x3d, 0xd9, 0x9e, 0xcc, 0xe9, 0xf6, 0xf4, 0x73, 0xb8, 0xad, 0xaf, 0xda, 0x75, 0x99, 0xdb,
	0x0a, 0x46, 0xb4, 0x83, 0x42, 0x4e, 0x5e, 0x30, 0x5f, 0x43, 0x25, 0x5f, 0x41, 0x65, 0x9a, 0xf2,
	0x74, 0xd4, 0x79, 0x1d, 0x15, 0x8d, 0x6b, 0xe9, 0x7c, 0xd0, 0x3e, 0x72, 0xaf, 0xda, 0x01, 0x73,
	0xfb, 0xa2, 0x4e, 0x15, 0x44, 0x63, 0x4c, 0xe1, 0xf8, 0xf4, 0x79, 0xe4, 0x5e, 0xf1, 0xcf, 0x26,
	0xd2, 0x3d, 0xaf, 0x8f, 0x62, 0x1c, 0x37, 0x9d, 0x09, 0x2c, 0xd7, 0x7f, 0xbf, 0xe7, 0x07, 0x14,
	0x39, 0x14, 0x3e, 0x13, 0x99, 0x4f, 0xdb, 0xe7, 0xae, 0x2f, 0x66, 0x73, 0xd3, 0xb9, 0x86, 0x4a,
	0xbe, 0x86, 0xc5, 0x03, 0xc4, 0x61, 0x13, 0xa9, 0x17, 0x74, 0xc3, 0x4a, 0x49, 0x3c, 0x9e, 0xaa,
	0x0c, 0x78, 0xec, 0xee, 0x98, 0xc5, 0x49, 0xb2, 0xdb, 0xbf, 0x81, 0x72, 0x16, 0x13, 0xf9, 0x09,
	0xdc, 0xda, 0xf7, 0x19, 0xd2, 0x4b, 0xb7, 0xdf, 0x62, 0x2e, 0x65, 0x2a, 0x40, 0x69, 0x24, 0x4f,
	0xd7, 0x23, 0xf7, 0xea, 0x78, 0x34, 0x78, 0x85, 0x54, 0x15, 0xe4, 0x18, 0x61, 0xbf, 0x35, 0x65,
	0x5a, 0x5d, 0x17, 0xe4, 0xa6, 0xcb, 0xce, 0x75, 0x90, 0xf9, 0x37, 0xb1, 0x21, 0x2f, 0x7e, 0x3d,
	0x98, 0x99, 0xbf, 0x1e, 0x04, 0x2d, 0x6a, 0x09, 0x72, 0x7a, 0x92, 0x2d, 0xa1, 0x0c, 0xf3, 0x47,
	0x6d, 0x6f, 0x80, 0x6a, 0x34, 0x92, 0x00, 0xe7, 0x3c, 0xe2, 0x29, 0x50, 0x90, 0x8d, 0xe2, 0x48,
	0x69, 0xd2, 0x60, 0x6e, 0x4f, 0x84, 0xa0, 0xe4, 0x88, 0x6f, 0x9e, 0xdc, 0xfa, 0x57, 0x50, 0x29,
	0x3b, 0xf3, 0x34, 0x9d, 0x7c, 0x01, 0xa5, 0x23, 0x64, 0xae, 0x48, 0xf0, 0x4a, 0x51, 0x30, 0x7f,
	0x14, 0x6b, 0xb9, 0x1d, 0xd1, 0x1a, 0x3e, 0xa3, 0x63, 0x27, 0xe6, 0x25, 0x5f, 0x42, 0xa9, 0x36,
	0x1c, 0xa2, 0x4b, 0xc3, 0x7d, 0xbf, 0x02, 0xe2, 0xe0, 0x1d, 0x79, 0xf0, 0x34, 0xa0, 0xaf, 0xc3,
	0xa1, 0xdb, 0x41, 0x07, 0xfb, 0x2e, 0xf3, 0x2e, 0x91, 0x7b, 0xc2, 0x89, 0xb9, 0xab, 0x5f, 0xc3,
	0x72, 0x5a, 0x2e, 0xb1, 0xc0, 0x7c, 0x8d, 0x63, 0xe5, 0x4d, 0xfe, 0xc9, 0x1d, 0x70, 0xe9, 0xf6,
	0x47, 0x3a, 0x65, 0x24, 0xf0, 0x55, 0xee, 0xb1, 0x61, 0x7f, 0x0b, 0xeb, 0x99, 0x37, 0xf0, 0x69,
	0xee, 0x34, 0x4c, 0x44, 0x45, 0x41, 0xbc, 0x4e, 0x9d, 0x86, 0x87, 0xee, 0x2b, 0xec, 0x2b, 0x61,
	0x1a, 0x8c, 0x22, 0x66, 0xc6, 0x11, 0xb3, 0xff, 0x61, 0x40, 0x29, 0xf2, 0xd3, 0x7b, 0x8e, 0xd2,
	0x51, 0xf4, 0xcc, 0x89, 0xe8, 0x4d, 0xc5, 0x99, 0x40, 0x9e, 0xa7, 0xa0, 0x08, 0xf3, 0x92, 0x23,
	0xbe, 0xf9, 0x13, 0x3c, 0x79, 0xe3, 0x23, 0x15, 0x17, 0x17, 0x64, 0xc7, 0x88, 0x10, 0xe4, 0xa7,
	0x30, 0x2f, 0xfb, 0xee, 0xc2, 0xf7, 0xf5, 0x5d, 0xc9, 0x63, 0xff, 0x33, 0xa7, 0x26, 0x12, 0x72,
	0x17, 0x80, 0x9b, 0xd7, 0xa4, 0x78, 0xe6, 0x5d, 0xa9, 0x7a, 0x96, 0xc0, 0x70, 0x27, 0x1d, 0x79,
	0x7e, 0x34, 0x9a, 0x98, 0x8e, 0x06, 0x05, 0x45, 0xe6, 0xb5, 0x32, 0x47, 0x83, 0xea, 0xcc, 0xae,
	0xcb, 0xb4, 0x4d, 0x1a, 0x54, 0x67, 0x04, 0x65, 0x3e, 0x3a, 0x23, 0x28, 0x3a, 0x21, 0x0a, 0xdf,
	0x93, 0x10, 0x55, 0x28, 0xf2, 0x9a, 0x20, 0x2a, 0x9d, 0x7c, 0xd6, 0x11, 0xcc, 0x25, 0xd7, 0x03,
	0x9f, 0x71, 0x07, 0x14, 0x65, 0x30, 0x15, 0xc8, 0x2d, 0xdc, 0xa3, 0x88, 0x2d, 0x46, 0x3d, 0xbf,
	0x57, 0x29, 0x09, 0x62, 0x02, 0xc3, 0xdd, 0xda, 0xb8, 0x62, 0xe8, 0x8b, 0x9e, 0x07, 0xd2, 0xad,
	0x11, 0x82, 0xdc, 0x87, 0xe2, 0x33, 0x0c, 0xe4, 0xf4, 0xb6, 0x28, 0x3c, 0xab, 0x74, 0xd3, 0x58,
	0x27, 0xa2, 0xdb, 0x7f, 0x37, 0x62, 0x66, 0x72, 0x0f, 0x0a, 0x75, 0xe4, 0x25, 0x44, 0x35, 0xa6,
	0xf8, 0x58, 0x33, 0xf0, 0x7c, 0xe6, 0x28, 0x2a, 0x37, 0x6a, 0xd7, 0x0b, 0x99, 0xeb, 0x77, 0xf4,
	0x9b, 0x8e, 0x60, 0xb2, 0x05, 0x0b, 0xed, 0x60, 0x78, 0x88, 0x67, 0x4c, 0xfd, 0xf2, 0x9a, 0x14,
	0xa2, 0xc9, 0xe4, 0x01, 0x2c, 0x3e, 0x0d, 0x18, 0x0b, 0x06, 0x8e, 0xd7, 0x3b, 0x97, 0x3f, 0xb8,
	0xa6, 0xb9, 0x93, 0x2c, 0xf6, 0xb6, 0xd0, 0x55, 0x10, 0x78, 0x9a, 0x1d, 0xba, 0xb2, 0xf0, 0x19,
	0x0e, 0xff, 0x14, 0x18, 0xf5, 0x86, 0x39, 0x26, 0xf0, 0xed, 0xff, 0x1a, 0xb0, 0x32, 0xf1, 0x9a,
	0xc8, 0x43, 0x15, 0x34, 0x43, 0x04, 0xed, 0x47, 0x99, 0x4f, 0x6e, 0x5b, 0xfc, 0x4d, 0x44, 0xd1,
	0x86, 0x82, 0xec, 0x2c, 0x19, 0x3f, 0xa8, 0x15, 0x85, 0xf3, 0xb4, 0x5d, 0xda, 0x43, 0x96, 0xf1,
	0x8b, 0x53, 0x51, 0xec, 0x0e, 0x94, 0x22, 0xd1, 0x04, 0xa0, 0x50, 0x77, 0x1a, 0xb5, 0x76, 0xc3,
	0x9a, 0x23, 0x45, 0xc8, 0x3b, 0x8d, 0xda, 0xae, 0x65, 0x90, 0x15, 0x58, 0x7c, 0xd1, 0xdc, 0xad,
	0xb5, 0x1b, 0x2f, 0x9b, 0xb5, 0xf6, 0x73, 0x2b, 0x47, 0x08, 0x2c, 0x2b, 0x44, 0xfd, 0xe4, 0xb8,
	0xdd, 0x38, 0x6e, 0x5b, 0x66, 0x82, 0xe9, 0xa8, 0xd1, 0xae, 0x59, 0x79, 0x2e, 0x6b, 0xb7, 0x71,
	0xd8, 0x68, 0x37, 0xac, 0x79, 0xfb, 0xad, 0x01, 0x1b, 0xcf, 0x90, 0x35, 0xfc, 0x0e, 0x1d, 0x8b,
	0x1c, 0x3e, 0xc0, 0xb1, 0x1e, 0x3f, 0x78, 0x0d, 0x08, 0x55, 0x7c, 0x79, 0x0d, 0x08, 0x65, 0x34,
	0x9b, 0x6e, 0x18, 0xbe, 0x09, 0xa8, 0x1e, 0xea, 0x22, 0x38, 0x1a, 0xbd, 0xcc, 0x6b, 0x46, 0x2f,
	0xfe, 0xab, 0x53, 0x74, 0x3b, 0x91, 0x1b, 0x45, 0x47, 0x41, 0xf6, 0x67, 0x50, 0x99, 0x56, 0x41,
	0xcd, 0x24, 0x16, 0x98, 0x07, 0xaa, 0x40, 0x2e, 0x39, 0xfc, 0xd3, 0xfe, 0x63, 0x0e, 0xa0, 0x35,
	0xf6, 0x3b, 0x32, 0x04, 0x9c, 0x21, 0xc4, 0x0b, 0xc1, 0x90, 0x77, 0xf8, 0x27, 0xd9, 0x80, 0x82,
	0x1f, 0x74, 0x31, 0x9a, 0x3a, 0x17, 0x38, 0xf4, 0xd2, 0xeb, 0x92, 0x4f, 0x21, 0xcf, 0xe2, 0x9e,
	0xa4, 0x0a, 0x48, 0x2c, 0x6a, 0x5b, 0xc6, 0x90, 0xb3, 0x70, 0x55, 0x43, 0x19, 0x43, 0x39, 0x71,
	0x28, 0x88, 0xe3, 0x99, 0x8c, 0x9b, 0x9c, 0x27, 0x14, 0x44, 0xb6, 0x20, 0xef, 0xeb, 0x06, 0xb5,
	0xb8, 0x53, 0x9e, 0x14, 0x2d, 0x9d, 0xc0, 0x39, 0xec, 0xa7, 0xf2, 0x49, 0x91, 0x45, 0x58, 0x18,
	0xf9, 0xaf, 0xfd, 0xe0, 0x8d, 0x6f, 0xcd, 0xf1, 0x88, 0x74, 0x84, 0x2f, 0x2c, 0x83, 0x7f, 0x77,
	0xc5, 0xb8, 0x65, 0xe5, 0x78, 0xa4, 0x87, 0x2e, 0x3b, 0xb7, 0x4c, 0xce, 0xde, 0x91, 0xf9, 0x6e,
	0xe5, 0xed, 0xbf, 0x19, 0xb0, 0x9c, 0x16, 0xce, 0xe3, 0xf2, 0x6a, 0xcc, 0x30, 0xe4, 0xd5, 0xca,
	0x10, 0x95, 0x27, 0x82, 0xb9, 0x8b, 0x06, 0xdd, 0x47, 0xca, 0x1b, 0xfc, 0x93, 0xd7, 0xe9, 0x01,
	0x4b, 0xd4, 0x69, 0x01, 0x90, 0x3b, 0x50, 0xe4, 0x2a, 0x8a, 0xce, 0x20, 0xcd, 0x2e, 0x09, 0xd7,
	0x71, 0x15, 0xc8, 0x43, 0x28, 0x53, 0x1c, 0x06, 0xa1, 0xc7, 0x02, 0x3a, 0xde, 0xef, 0xa2, 0xcf,
	0xbc, 0x33, 0x0f, 0xa9, 0xf2, 0xc3, 0x7a, 0x4c, 0x7b, 0xe9, 0x45, 0x44, 0xbb, 0x0e, 0xeb, 0xcd,
	0x11, 0x8b, 0x55, 0x4d, 0x8e, 0xd0, 0x61, 0x7a, 0x84, 0x56, 0xa0, 0x50, 0x36, 0xec, 0x45, 0xca,
	0x86, 0x3d, 0xfb, 0x0f, 0xb0, 0x21, 0x7f, 0xe1, 0x25, 0xe5, 0xc8, 0x17, 0x3a, 0x1d, 0xfc, 0x0a,
	0x2c, 0x9c, 0xf5, 0x5d, 0xc6, 0xd0, 0x57, 0xe3, 0xaf, 0x06, 0x79, 0xe8, 0x86, 0xb2, 0x09, 0xc8,
	0xae, 0xa7, 0x20, 0xde, 0xd5, 0xfa, 0x6e, 0xc8, 0x5a, 0x78, 0x71, 0xe2, 0xf7, 0xc7, 0xea, 0x47,
	0x67, 0x12, 0x75, 0xff, 0x73, 0x28, 0xea, 0x42, 0xcd, 0xe3, 0xf0, 0xe2, 0xf8, 0xe0, 0xf8, 0xe4,
	0xf4, 0x58, 0x26, 0xe2, 0x61, 0xa3, 0xb6, 0x67, 0x19, 0x64, 0x19, 0xa0, 0x7e, 0x72, 0x78, 0xd8,
	0xa8, 0xb7, 0xf7, 0x4f, 0x8e, 0xad, 0xdc, 0xce, 0x5f, 0x0d, 0x58, 0xe2, 0x67, 0x9a, 0x34, 0xb8,
	0xf4, 0xba, 0x48, 0xc9, 0x2f, 0xa0, 0xa8, 0xd7, 0xd0, 0x44, 0xbd, 0xbc, 0x89, 0x5d, 0x77, 0xf5,
	0xf6, 0x24, 0x5a, 0xfa, 0xca, 0x9e, 0x23, 0x4f, 0xa0, 0x14, 0x2d, 0x58, 0x89, 0x62, 0x9b, 0xdc,
	0x42, 0x57, 0x37, 0xa6, 0xf0, 0xfa, 0xfc, 0x03, 0x63, 0xe7, 0x5b, 0x28, 0x27, 0xd5, 0x69, 0x31,
	0x8a, 0xee, 0x00, 0x29, 0x69, 0xc0, 0xb2, 0xbe, 0x4f, 0xe2, 0x66, 0x56, 0x6e, 0xcb, 0x78, 0x60,
	0xec, 0xfc, 0x4b, 0x99, 0xeb, 0x60, 0x07, 0xbd, 0x4b, 0xa4, 0xa4, 0x06, 0x10, 0x6f, 0x54, 0x89,
	0x52, 0x6d, 0x6a, 0xdd, 0x5b, 0xad, 0x4c, 0x13, 0x22, 0xa3, 0x6b, 0x00, 0xf1, 0x16, 0x53, 0x8b,
	0x98, 0x5a, 0xab, 0x6a, 0x11, 0xd3, 0x0b, 0x4f, 0x29, 0x22, 0xde, 0x2a, 0x6a, 0x11, 0x53, 0xab,
	0x4c, 0x2d, 0x62, 0x7a, 0x01, 0x69, 0xcf, 0xed, 0xfc, 0xcf, 0x00, 0x92, 0xb4, 0x4c, 0x79, 0xe9,
	0x00, 0xac, 0x58, 0x69, 0x85, 0x7b, 0x1f, 0x2b, 0xb9, 0xf7, 0xb8, 0xb0, 0x58, 0xfd, 0xb4, 0xb0,
	0x99, 0xec, 0xd5, 0xc2, 0x62, 0x43, 0xd2, 0xc2, 0x66, 0xb2, 0x5c, 0xc4, 0xf5, 0x3f, 0xbc, 0xd0,
	0xc8, 0xf5, 0x92, 0x58, 0x3c, 0x21, 0x25, 0xbb, 0xb0, 0x98, 0xd8, 0xec, 0x11, 0x25, 0x61, 0x7a,
	0x6b, 0x58, 0xfd, 0x28, 0x83, 0x12, 0x45, 0xe6, 0x19, 0x2c, 0x25, 0x77, 0x71, 0x44, 0x31, 0x67,
	0x6c, 0xfa, 0xaa, 0xd5, 0x2c, 0x52, 0x52, 0x50, 0x72, 0x7f, 0xa6, 0x05, 0x65, 0x6c, 0xe7, 0xb4,
	0xa0, 0xac, 0x75, 0x9b, 0x3d, 0xb7, 0xf3, 0x8d, 0x8c, 0xb3, 0xe8, 0xb8, 0x61, 0x94, 0xb6, 0x4f,
	0xa0, 0x14, 0xed, 0xc7, 0x74, 0xe6, 0x4d, 0x2e, 0xd9, 0x74, 0xe6, 0x4d, 0x2d, 0xd2, 0x44, 0xe6,
	0xd5, 0xa1, 0x28, 0xab, 0x17, 0x52, 0xf2, 0x05, 0x14, 0xe4, 0x37, 0x59, 0x53, 0x1d, 0x22, 0xb9,
	0x45, 0xab, 0x96, 0xd3, 0xc8, 0x84, 0x90, 0x35, 0x58, 0x15, 0x53, 0x87, 0xec, 0x00, 0x3c, 0x09,
	0x91, 0x4e, 0x20, 0x4f, 0xa9, 0xc7, 0x90, 0xee, 0xbc, 0x35, 0xe1, 0x16, 0xc7, 0xaa, 0x5f, 0x82,
	0x48, 0xc9, 0xaf, 0xe0, 0x56, 0x6a, 0xf7, 0x44, 0xaa, 0xc9, 0xe7, 0x98, 0xde, 0x9e, 0x54, 0xef,
	0x64, 0xd2, 0x92, 0xde, 0x4e, 0x6e, 0x44, 0xb4, 0xb7, 0x33, 0xf6, 0x30, 0xda, 0xdb, 0x59, 0x0b,
	0x14, 0x7b, 0x8e, 0xec, 0xc3, 0x52, 0x72, 0x2b, 0xa5, 0x05, 0x65, 0x2c, 0xb8, 0xb4, 0xa0, 0xac,
	0x25, 0x16, 0xf7, 0x0d, 0x7f, 0x90, 0x89, 0x4d, 0x92, 0x7e, 0x90, 0xd3, 0x0b, 0x2b, 0xfd, 0x20,
	0x33, 0xd6, 0x4e, 0xf6, 0x1c, 0xf7, 0x52, 0x6a, 0x29, 0xa2, 0xbd, 0x94, 0xb5, 0x97, 0xd1, 0x5e,
	0xca, 0xdc, 0xa2, 0xd8, 0x73, 0x3b, 0x08, 0xcb, 0x7c, 0x6c, 0x3f, 0xc0, 0xf1, 0x91, 0xeb, 0xbb,
	0x3d, 0xa4, 0xa4, 0x05, 0xd6, 0xe4, 0x84, 0x43, 0x3e, 0xd1, 0xc3, 0x6b, 0xe6, 0xf0, 0x55, 0xbd,
	0x7b, 0x1d, 0x39, 0xba, 0xe6, 0x4f, 0x06, 0x2c, 0xc6, 0x2d, 0x31, 0x24, 0x8f, 0xc1, 0x6c, 0x8e,
	0x18, 0xb1, 0x26, 0x87, 0x8f, 0x48, 0xdd, 0xac, 0x4e, 0xcc, 0x13, 0x9d, 0xfc, 0x32, 0x7a, 0x97,
	0x9f, 0x24, 0x9f, 0xe0, 0x54, 0xbf, 0xad, 0x4e, 0xc9, 0xe6, 0x11, 0x78, 0x55, 0x10, 0xff, 0xc4,
	0x7d, 0xf8, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x03, 0xff, 0x89, 0x92, 0xd2, 0x1d, 0x00, 0x00,
}
